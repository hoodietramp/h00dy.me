{
  "resolvedId": "C:/Users/h00dy/Documents/github/h00dy.me/node_modules/h3/dist/index.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { withoutTrailingSlash, withoutBase, getQuery as getQuery$1, decode, decodePath, withLeadingSlash, parseURL, joinURL } from 'ufo';\r\nimport { parse as parse$1, serialize } from 'cookie-es';\r\nimport { objectHash } from 'ohash';\r\nimport { createRouter as createRouter$1, toRouteMatcher } from 'radix3';\r\nimport destr from 'destr';\r\nimport { defu } from 'defu';\r\nimport crypto from 'uncrypto';\r\nimport { seal, defaults, unseal } from 'iron-webcrypto';\r\nimport { IncomingMessage } from 'unenv/runtime/node/http/_request';\r\nimport { ServerResponse } from 'unenv/runtime/node/http/_response';\r\n\r\nfunction useBase(base, handler) {\r\n  base = withoutTrailingSlash(base);\r\n  if (!base || base === \"/\") {\r\n    return handler;\r\n  }\r\n  return eventHandler(async (event) => {\r\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\r\n    const _path = event._path || event.node.req.url || \"/\";\r\n    event._path = withoutBase(event.path || \"/\", base);\r\n    event.node.req.url = event._path;\r\n    try {\r\n      return await handler(event);\r\n    } finally {\r\n      event._path = event.node.req.url = _path;\r\n    }\r\n  });\r\n}\r\n\r\nfunction hasProp(obj, prop) {\r\n  try {\r\n    return prop in obj;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nvar __defProp$2 = Object.defineProperty;\r\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __publicField$2 = (obj, key, value) => {\r\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\r\n  return value;\r\n};\r\nclass H3Error extends Error {\r\n  constructor(message, opts = {}) {\r\n    super(message, opts);\r\n    __publicField$2(this, \"statusCode\", 500);\r\n    __publicField$2(this, \"fatal\", false);\r\n    __publicField$2(this, \"unhandled\", false);\r\n    __publicField$2(this, \"statusMessage\");\r\n    __publicField$2(this, \"data\");\r\n    __publicField$2(this, \"cause\");\r\n    if (opts.cause && !this.cause) {\r\n      this.cause = opts.cause;\r\n    }\r\n  }\r\n  toJSON() {\r\n    const obj = {\r\n      message: this.message,\r\n      statusCode: sanitizeStatusCode(this.statusCode, 500)\r\n    };\r\n    if (this.statusMessage) {\r\n      obj.statusMessage = sanitizeStatusMessage(this.statusMessage);\r\n    }\r\n    if (this.data !== void 0) {\r\n      obj.data = this.data;\r\n    }\r\n    return obj;\r\n  }\r\n}\r\n__publicField$2(H3Error, \"__h3_error__\", true);\r\nfunction createError(input) {\r\n  if (typeof input === \"string\") {\r\n    return new H3Error(input);\r\n  }\r\n  if (isError(input)) {\r\n    return input;\r\n  }\r\n  const err = new H3Error(input.message ?? input.statusMessage ?? \"\", {\r\n    cause: input.cause || input\r\n  });\r\n  if (hasProp(input, \"stack\")) {\r\n    try {\r\n      Object.defineProperty(err, \"stack\", {\r\n        get() {\r\n          return input.stack;\r\n        }\r\n      });\r\n    } catch {\r\n      try {\r\n        err.stack = input.stack;\r\n      } catch {\r\n      }\r\n    }\r\n  }\r\n  if (input.data) {\r\n    err.data = input.data;\r\n  }\r\n  if (input.statusCode) {\r\n    err.statusCode = sanitizeStatusCode(input.statusCode, err.statusCode);\r\n  } else if (input.status) {\r\n    err.statusCode = sanitizeStatusCode(input.status, err.statusCode);\r\n  }\r\n  if (input.statusMessage) {\r\n    err.statusMessage = input.statusMessage;\r\n  } else if (input.statusText) {\r\n    err.statusMessage = input.statusText;\r\n  }\r\n  if (err.statusMessage) {\r\n    const originalMessage = err.statusMessage;\r\n    const sanitizedMessage = sanitizeStatusMessage(err.statusMessage);\r\n    if (sanitizedMessage !== originalMessage) {\r\n      console.warn(\r\n        \"[h3] Please prefer using `message` for longer error messages instead of `statusMessage`. In the future, `statusMessage` will be sanitized by default.\"\r\n      );\r\n    }\r\n  }\r\n  if (input.fatal !== void 0) {\r\n    err.fatal = input.fatal;\r\n  }\r\n  if (input.unhandled !== void 0) {\r\n    err.unhandled = input.unhandled;\r\n  }\r\n  return err;\r\n}\r\nfunction sendError(event, error, debug) {\r\n  if (event.handled) {\r\n    return;\r\n  }\r\n  const h3Error = isError(error) ? error : createError(error);\r\n  const responseBody = {\r\n    statusCode: h3Error.statusCode,\r\n    statusMessage: h3Error.statusMessage,\r\n    stack: [],\r\n    data: h3Error.data\r\n  };\r\n  if (debug) {\r\n    responseBody.stack = (h3Error.stack || \"\").split(\"\\n\").map((l) => l.trim());\r\n  }\r\n  if (event.handled) {\r\n    return;\r\n  }\r\n  const _code = Number.parseInt(h3Error.statusCode);\r\n  setResponseStatus(event, _code, h3Error.statusMessage);\r\n  event.node.res.setHeader(\"content-type\", MIMES.json);\r\n  event.node.res.end(JSON.stringify(responseBody, void 0, 2));\r\n}\r\nfunction isError(input) {\r\n  return input?.constructor?.__h3_error__ === true;\r\n}\r\n\r\nfunction parse(multipartBodyBuffer, boundary) {\r\n  let lastline = \"\";\r\n  let state = 0 /* INIT */;\r\n  let buffer = [];\r\n  const allParts = [];\r\n  let currentPartHeaders = [];\r\n  for (let i = 0; i < multipartBodyBuffer.length; i++) {\r\n    const prevByte = i > 0 ? multipartBodyBuffer[i - 1] : null;\r\n    const currByte = multipartBodyBuffer[i];\r\n    const newLineChar = currByte === 10 || currByte === 13;\r\n    if (!newLineChar) {\r\n      lastline += String.fromCodePoint(currByte);\r\n    }\r\n    const newLineDetected = currByte === 10 && prevByte === 13;\r\n    if (0 /* INIT */ === state && newLineDetected) {\r\n      if (\"--\" + boundary === lastline) {\r\n        state = 1 /* READING_HEADERS */;\r\n      }\r\n      lastline = \"\";\r\n    } else if (1 /* READING_HEADERS */ === state && newLineDetected) {\r\n      if (lastline.length > 0) {\r\n        const i2 = lastline.indexOf(\":\");\r\n        if (i2 > 0) {\r\n          const name = lastline.slice(0, i2).toLowerCase();\r\n          const value = lastline.slice(i2 + 1).trim();\r\n          currentPartHeaders.push([name, value]);\r\n        }\r\n      } else {\r\n        state = 2 /* READING_DATA */;\r\n        buffer = [];\r\n      }\r\n      lastline = \"\";\r\n    } else if (2 /* READING_DATA */ === state) {\r\n      if (lastline.length > boundary.length + 4) {\r\n        lastline = \"\";\r\n      }\r\n      if (\"--\" + boundary === lastline) {\r\n        const j = buffer.length - lastline.length;\r\n        const part = buffer.slice(0, j - 1);\r\n        allParts.push(process(part, currentPartHeaders));\r\n        buffer = [];\r\n        currentPartHeaders = [];\r\n        lastline = \"\";\r\n        state = 3 /* READING_PART_SEPARATOR */;\r\n      } else {\r\n        buffer.push(currByte);\r\n      }\r\n      if (newLineDetected) {\r\n        lastline = \"\";\r\n      }\r\n    } else if (3 /* READING_PART_SEPARATOR */ === state && newLineDetected) {\r\n      state = 1 /* READING_HEADERS */;\r\n    }\r\n  }\r\n  return allParts;\r\n}\r\nfunction process(data, headers) {\r\n  const dataObj = {};\r\n  const contentDispositionHeader = headers.find((h) => h[0] === \"content-disposition\")?.[1] || \"\";\r\n  for (const i of contentDispositionHeader.split(\";\")) {\r\n    const s = i.split(\"=\");\r\n    if (s.length !== 2) {\r\n      continue;\r\n    }\r\n    const key = (s[0] || \"\").trim();\r\n    if (key === \"name\" || key === \"filename\") {\r\n      const _value = (s[1] || \"\").trim().replace(/\"/g, \"\");\r\n      dataObj[key] = Buffer.from(_value, \"latin1\").toString(\"utf8\");\r\n    }\r\n  }\r\n  const contentType = headers.find((h) => h[0] === \"content-type\")?.[1] || \"\";\r\n  if (contentType) {\r\n    dataObj.type = contentType;\r\n  }\r\n  dataObj.data = Buffer.from(data);\r\n  return dataObj;\r\n}\r\n\r\nasync function validateData(data, fn) {\r\n  try {\r\n    const res = await fn(data);\r\n    if (res === false) {\r\n      throw createValidationError();\r\n    }\r\n    if (res === true) {\r\n      return data;\r\n    }\r\n    return res ?? data;\r\n  } catch (error) {\r\n    throw createValidationError(error);\r\n  }\r\n}\r\nfunction createValidationError(validateError) {\r\n  throw createError({\r\n    status: 400,\r\n    statusMessage: \"Validation Error\",\r\n    message: validateError?.message || \"Validation Error\",\r\n    data: validateError\r\n  });\r\n}\r\n\r\nfunction getQuery(event) {\r\n  return getQuery$1(event.path || \"\");\r\n}\r\nfunction getValidatedQuery(event, validate) {\r\n  const query = getQuery(event);\r\n  return validateData(query, validate);\r\n}\r\nfunction getRouterParams(event, opts = {}) {\r\n  let params = event.context.params || {};\r\n  if (opts.decode) {\r\n    params = { ...params };\r\n    for (const key in params) {\r\n      params[key] = decode(params[key]);\r\n    }\r\n  }\r\n  return params;\r\n}\r\nfunction getValidatedRouterParams(event, validate, opts = {}) {\r\n  const routerParams = getRouterParams(event, opts);\r\n  return validateData(routerParams, validate);\r\n}\r\nfunction getRouterParam(event, name, opts = {}) {\r\n  const params = getRouterParams(event, opts);\r\n  return params[name];\r\n}\r\nfunction getMethod(event, defaultMethod = \"GET\") {\r\n  return (event.node.req.method || defaultMethod).toUpperCase();\r\n}\r\nfunction isMethod(event, expected, allowHead) {\r\n  if (allowHead && event.method === \"HEAD\") {\r\n    return true;\r\n  }\r\n  if (typeof expected === \"string\") {\r\n    if (event.method === expected) {\r\n      return true;\r\n    }\r\n  } else if (expected.includes(event.method)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nfunction assertMethod(event, expected, allowHead) {\r\n  if (!isMethod(event, expected, allowHead)) {\r\n    throw createError({\r\n      statusCode: 405,\r\n      statusMessage: \"HTTP method is not allowed.\"\r\n    });\r\n  }\r\n}\r\nfunction getRequestHeaders(event) {\r\n  const _headers = {};\r\n  for (const key in event.node.req.headers) {\r\n    const val = event.node.req.headers[key];\r\n    _headers[key] = Array.isArray(val) ? val.filter(Boolean).join(\", \") : val;\r\n  }\r\n  return _headers;\r\n}\r\nconst getHeaders = getRequestHeaders;\r\nfunction getRequestHeader(event, name) {\r\n  const headers = getRequestHeaders(event);\r\n  const value = headers[name.toLowerCase()];\r\n  return value;\r\n}\r\nconst getHeader = getRequestHeader;\r\nfunction getRequestHost(event, opts = {}) {\r\n  if (opts.xForwardedHost) {\r\n    const xForwardedHost = event.node.req.headers[\"x-forwarded-host\"];\r\n    if (xForwardedHost) {\r\n      return xForwardedHost;\r\n    }\r\n  }\r\n  return event.node.req.headers.host || \"localhost\";\r\n}\r\nfunction getRequestProtocol(event, opts = {}) {\r\n  if (opts.xForwardedProto !== false && event.node.req.headers[\"x-forwarded-proto\"] === \"https\") {\r\n    return \"https\";\r\n  }\r\n  return event.node.req.connection?.encrypted ? \"https\" : \"http\";\r\n}\r\nconst DOUBLE_SLASH_RE = /[/\\\\]{2,}/g;\r\nfunction getRequestPath(event) {\r\n  const path = (event.node.req.url || \"/\").replace(DOUBLE_SLASH_RE, \"/\");\r\n  return path;\r\n}\r\nfunction getRequestURL(event, opts = {}) {\r\n  const host = getRequestHost(event, opts);\r\n  const protocol = getRequestProtocol(event);\r\n  const path = (event.node.req.originalUrl || event.path).replace(\r\n    /^[/\\\\]+/g,\r\n    \"/\"\r\n  );\r\n  return new URL(path, `${protocol}://${host}`);\r\n}\r\nfunction toWebRequest(event) {\r\n  return event.web?.request || new Request(getRequestURL(event), {\r\n    // @ts-ignore Undici option\r\n    duplex: \"half\",\r\n    method: event.method,\r\n    headers: event.headers,\r\n    body: getRequestWebStream(event)\r\n  });\r\n}\r\nfunction getRequestIP(event, opts = {}) {\r\n  if (event.context.clientAddress) {\r\n    return event.context.clientAddress;\r\n  }\r\n  if (opts.xForwardedFor) {\r\n    const xForwardedFor = getRequestHeader(event, \"x-forwarded-for\")?.split(\",\").shift()?.trim();\r\n    if (xForwardedFor) {\r\n      return xForwardedFor;\r\n    }\r\n  }\r\n  if (event.node.req.socket.remoteAddress) {\r\n    return event.node.req.socket.remoteAddress;\r\n  }\r\n}\r\n\r\nconst RawBodySymbol = Symbol.for(\"h3RawBody\");\r\nconst ParsedBodySymbol = Symbol.for(\"h3ParsedBody\");\r\nconst PayloadMethods$1 = [\"PATCH\", \"POST\", \"PUT\", \"DELETE\"];\r\nfunction readRawBody(event, encoding = \"utf8\") {\r\n  assertMethod(event, PayloadMethods$1);\r\n  const _rawBody = event._requestBody || event.web?.request?.body || event.node.req[RawBodySymbol] || event.node.req.rawBody || event.node.req.body;\r\n  if (_rawBody) {\r\n    const promise2 = Promise.resolve(_rawBody).then((_resolved) => {\r\n      if (Buffer.isBuffer(_resolved)) {\r\n        return _resolved;\r\n      }\r\n      if (typeof _resolved.pipeTo === \"function\") {\r\n        return new Promise((resolve, reject) => {\r\n          const chunks = [];\r\n          _resolved.pipeTo(\r\n            new WritableStream({\r\n              write(chunk) {\r\n                chunks.push(chunk);\r\n              },\r\n              close() {\r\n                resolve(Buffer.concat(chunks));\r\n              },\r\n              abort(reason) {\r\n                reject(reason);\r\n              }\r\n            })\r\n          ).catch(reject);\r\n        });\r\n      } else if (typeof _resolved.pipe === \"function\") {\r\n        return new Promise((resolve, reject) => {\r\n          const chunks = [];\r\n          _resolved.on(\"data\", (chunk) => {\r\n            chunks.push(chunk);\r\n          }).on(\"end\", () => {\r\n            resolve(Buffer.concat(chunks));\r\n          }).on(\"error\", reject);\r\n        });\r\n      }\r\n      if (_resolved.constructor === Object) {\r\n        return Buffer.from(JSON.stringify(_resolved));\r\n      }\r\n      return Buffer.from(_resolved);\r\n    });\r\n    return encoding ? promise2.then((buff) => buff.toString(encoding)) : promise2;\r\n  }\r\n  if (!Number.parseInt(event.node.req.headers[\"content-length\"] || \"\")) {\r\n    return Promise.resolve(void 0);\r\n  }\r\n  const promise = event.node.req[RawBodySymbol] = new Promise(\r\n    (resolve, reject) => {\r\n      const bodyData = [];\r\n      event.node.req.on(\"error\", (err) => {\r\n        reject(err);\r\n      }).on(\"data\", (chunk) => {\r\n        bodyData.push(chunk);\r\n      }).on(\"end\", () => {\r\n        resolve(Buffer.concat(bodyData));\r\n      });\r\n    }\r\n  );\r\n  const result = encoding ? promise.then((buff) => buff.toString(encoding)) : promise;\r\n  return result;\r\n}\r\nasync function readBody(event, options = {}) {\r\n  const request = event.node.req;\r\n  if (hasProp(request, ParsedBodySymbol)) {\r\n    return request[ParsedBodySymbol];\r\n  }\r\n  const contentType = request.headers[\"content-type\"] || \"\";\r\n  const body = await readRawBody(event);\r\n  let parsed;\r\n  if (contentType === \"application/json\") {\r\n    parsed = _parseJSON(body, options.strict ?? true);\r\n  } else if (contentType.startsWith(\"application/x-www-form-urlencoded\")) {\r\n    parsed = _parseURLEncodedBody(body);\r\n  } else if (contentType.startsWith(\"text/\")) {\r\n    parsed = body;\r\n  } else {\r\n    parsed = _parseJSON(body, options.strict ?? false);\r\n  }\r\n  request[ParsedBodySymbol] = parsed;\r\n  return parsed;\r\n}\r\nasync function readValidatedBody(event, validate) {\r\n  const _body = await readBody(event, { strict: true });\r\n  return validateData(_body, validate);\r\n}\r\nasync function readMultipartFormData(event) {\r\n  const contentType = getRequestHeader(event, \"content-type\");\r\n  if (!contentType || !contentType.startsWith(\"multipart/form-data\")) {\r\n    return;\r\n  }\r\n  const boundary = contentType.match(/boundary=([^;]*)(;|$)/i)?.[1];\r\n  if (!boundary) {\r\n    return;\r\n  }\r\n  const body = await readRawBody(event, false);\r\n  if (!body) {\r\n    return;\r\n  }\r\n  return parse(body, boundary);\r\n}\r\nasync function readFormData(event) {\r\n  return await toWebRequest(event).formData();\r\n}\r\nfunction getRequestWebStream(event) {\r\n  if (!PayloadMethods$1.includes(event.method)) {\r\n    return;\r\n  }\r\n  const bodyStream = event.web?.request?.body || event._requestBody;\r\n  if (bodyStream) {\r\n    return bodyStream;\r\n  }\r\n  const _hasRawBody = RawBodySymbol in event.node.req || \"rawBody\" in event.node.req || \"body\" in event.node.req || \"__unenv__\" in event.node.req;\r\n  if (_hasRawBody) {\r\n    return new ReadableStream({\r\n      async start(controller) {\r\n        const _rawBody = await readRawBody(event, false);\r\n        if (_rawBody) {\r\n          controller.enqueue(_rawBody);\r\n        }\r\n        controller.close();\r\n      }\r\n    });\r\n  }\r\n  return new ReadableStream({\r\n    start: (controller) => {\r\n      event.node.req.on(\"data\", (chunk) => {\r\n        controller.enqueue(chunk);\r\n      });\r\n      event.node.req.on(\"end\", () => {\r\n        controller.close();\r\n      });\r\n      event.node.req.on(\"error\", (err) => {\r\n        controller.error(err);\r\n      });\r\n    }\r\n  });\r\n}\r\nfunction _parseJSON(body = \"\", strict) {\r\n  if (!body) {\r\n    return void 0;\r\n  }\r\n  try {\r\n    return destr(body, { strict });\r\n  } catch {\r\n    throw createError({\r\n      statusCode: 400,\r\n      statusMessage: \"Bad Request\",\r\n      message: \"Invalid JSON body\"\r\n    });\r\n  }\r\n}\r\nfunction _parseURLEncodedBody(body) {\r\n  const form = new URLSearchParams(body);\r\n  const parsedForm = /* @__PURE__ */ Object.create(null);\r\n  for (const [key, value] of form.entries()) {\r\n    if (hasProp(parsedForm, key)) {\r\n      if (!Array.isArray(parsedForm[key])) {\r\n        parsedForm[key] = [parsedForm[key]];\r\n      }\r\n      parsedForm[key].push(value);\r\n    } else {\r\n      parsedForm[key] = value;\r\n    }\r\n  }\r\n  return parsedForm;\r\n}\r\n\r\nfunction handleCacheHeaders(event, opts) {\r\n  const cacheControls = [\"public\", ...opts.cacheControls || []];\r\n  let cacheMatched = false;\r\n  if (opts.maxAge !== void 0) {\r\n    cacheControls.push(`max-age=${+opts.maxAge}`, `s-maxage=${+opts.maxAge}`);\r\n  }\r\n  if (opts.modifiedTime) {\r\n    const modifiedTime = new Date(opts.modifiedTime);\r\n    const ifModifiedSince = event.node.req.headers[\"if-modified-since\"];\r\n    event.node.res.setHeader(\"last-modified\", modifiedTime.toUTCString());\r\n    if (ifModifiedSince && new Date(ifModifiedSince) >= opts.modifiedTime) {\r\n      cacheMatched = true;\r\n    }\r\n  }\r\n  if (opts.etag) {\r\n    event.node.res.setHeader(\"etag\", opts.etag);\r\n    const ifNonMatch = event.node.req.headers[\"if-none-match\"];\r\n    if (ifNonMatch === opts.etag) {\r\n      cacheMatched = true;\r\n    }\r\n  }\r\n  event.node.res.setHeader(\"cache-control\", cacheControls.join(\", \"));\r\n  if (cacheMatched) {\r\n    event.node.res.statusCode = 304;\r\n    if (!event.handled) {\r\n      event.node.res.end();\r\n    }\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nconst MIMES = {\r\n  html: \"text/html\",\r\n  json: \"application/json\"\r\n};\r\n\r\nconst DISALLOWED_STATUS_CHARS = /[^\\u0009\\u0020-\\u007E]/g;\r\nfunction sanitizeStatusMessage(statusMessage = \"\") {\r\n  return statusMessage.replace(DISALLOWED_STATUS_CHARS, \"\");\r\n}\r\nfunction sanitizeStatusCode(statusCode, defaultStatusCode = 200) {\r\n  if (!statusCode) {\r\n    return defaultStatusCode;\r\n  }\r\n  if (typeof statusCode === \"string\") {\r\n    statusCode = Number.parseInt(statusCode, 10);\r\n  }\r\n  if (statusCode < 100 || statusCode > 999) {\r\n    return defaultStatusCode;\r\n  }\r\n  return statusCode;\r\n}\r\n\r\nfunction parseCookies(event) {\r\n  return parse$1(event.node.req.headers.cookie || \"\");\r\n}\r\nfunction getCookie(event, name) {\r\n  return parseCookies(event)[name];\r\n}\r\nfunction setCookie(event, name, value, serializeOptions) {\r\n  serializeOptions = { path: \"/\", ...serializeOptions };\r\n  const cookieStr = serialize(name, value, serializeOptions);\r\n  let setCookies = event.node.res.getHeader(\"set-cookie\");\r\n  if (!Array.isArray(setCookies)) {\r\n    setCookies = [setCookies];\r\n  }\r\n  const _optionsHash = objectHash(serializeOptions);\r\n  setCookies = setCookies.filter((cookieValue) => {\r\n    return cookieValue && _optionsHash !== objectHash(parse$1(cookieValue));\r\n  });\r\n  event.node.res.setHeader(\"set-cookie\", [...setCookies, cookieStr]);\r\n}\r\nfunction deleteCookie(event, name, serializeOptions) {\r\n  setCookie(event, name, \"\", {\r\n    ...serializeOptions,\r\n    maxAge: 0\r\n  });\r\n}\r\nfunction splitCookiesString(cookiesString) {\r\n  if (Array.isArray(cookiesString)) {\r\n    return cookiesString.flatMap((c) => splitCookiesString(c));\r\n  }\r\n  if (typeof cookiesString !== \"string\") {\r\n    return [];\r\n  }\r\n  const cookiesStrings = [];\r\n  let pos = 0;\r\n  let start;\r\n  let ch;\r\n  let lastComma;\r\n  let nextStart;\r\n  let cookiesSeparatorFound;\r\n  const skipWhitespace = () => {\r\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\r\n      pos += 1;\r\n    }\r\n    return pos < cookiesString.length;\r\n  };\r\n  const notSpecialChar = () => {\r\n    ch = cookiesString.charAt(pos);\r\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\r\n  };\r\n  while (pos < cookiesString.length) {\r\n    start = pos;\r\n    cookiesSeparatorFound = false;\r\n    while (skipWhitespace()) {\r\n      ch = cookiesString.charAt(pos);\r\n      if (ch === \",\") {\r\n        lastComma = pos;\r\n        pos += 1;\r\n        skipWhitespace();\r\n        nextStart = pos;\r\n        while (pos < cookiesString.length && notSpecialChar()) {\r\n          pos += 1;\r\n        }\r\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\r\n          cookiesSeparatorFound = true;\r\n          pos = nextStart;\r\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\r\n          start = pos;\r\n        } else {\r\n          pos = lastComma + 1;\r\n        }\r\n      } else {\r\n        pos += 1;\r\n      }\r\n    }\r\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\r\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\r\n    }\r\n  }\r\n  return cookiesStrings;\r\n}\r\n\r\nfunction serializeIterableValue(value) {\r\n  switch (typeof value) {\r\n    case \"string\": {\r\n      return value;\r\n    }\r\n    case \"boolean\":\r\n    case \"number\":\r\n    case \"bigint\":\r\n    case \"symbol\": {\r\n      return value.toString();\r\n    }\r\n    case \"function\":\r\n    case \"undefined\": {\r\n      return void 0;\r\n    }\r\n    case \"object\": {\r\n      if (value instanceof Uint8Array) {\r\n        return value;\r\n      }\r\n      return JSON.stringify(value);\r\n    }\r\n  }\r\n}\r\nfunction coerceIterable(iterable) {\r\n  if (typeof iterable === \"function\") {\r\n    iterable = iterable();\r\n  }\r\n  if (Symbol.iterator in iterable) {\r\n    return iterable[Symbol.iterator]();\r\n  }\r\n  if (Symbol.asyncIterator in iterable) {\r\n    return iterable[Symbol.asyncIterator]();\r\n  }\r\n  return iterable;\r\n}\r\n\r\nconst defer = typeof setImmediate === \"undefined\" ? (fn) => fn() : setImmediate;\r\nfunction send(event, data, type) {\r\n  if (type) {\r\n    defaultContentType(event, type);\r\n  }\r\n  return new Promise((resolve) => {\r\n    defer(() => {\r\n      if (!event.handled) {\r\n        event.node.res.end(data);\r\n      }\r\n      resolve();\r\n    });\r\n  });\r\n}\r\nfunction sendNoContent(event, code) {\r\n  if (event.handled) {\r\n    return;\r\n  }\r\n  if (!code && event.node.res.statusCode !== 200) {\r\n    code = event.node.res.statusCode;\r\n  }\r\n  const _code = sanitizeStatusCode(code, 204);\r\n  if (_code === 204) {\r\n    event.node.res.removeHeader(\"content-length\");\r\n  }\r\n  event.node.res.writeHead(_code);\r\n  event.node.res.end();\r\n}\r\nfunction setResponseStatus(event, code, text) {\r\n  if (code) {\r\n    event.node.res.statusCode = sanitizeStatusCode(\r\n      code,\r\n      event.node.res.statusCode\r\n    );\r\n  }\r\n  if (text) {\r\n    event.node.res.statusMessage = sanitizeStatusMessage(text);\r\n  }\r\n}\r\nfunction getResponseStatus(event) {\r\n  return event.node.res.statusCode;\r\n}\r\nfunction getResponseStatusText(event) {\r\n  return event.node.res.statusMessage;\r\n}\r\nfunction defaultContentType(event, type) {\r\n  if (type && event.node.res.statusCode !== 304 && !event.node.res.getHeader(\"content-type\")) {\r\n    event.node.res.setHeader(\"content-type\", type);\r\n  }\r\n}\r\nfunction sendRedirect(event, location, code = 302) {\r\n  event.node.res.statusCode = sanitizeStatusCode(\r\n    code,\r\n    event.node.res.statusCode\r\n  );\r\n  event.node.res.setHeader(\"location\", location);\r\n  const encodedLoc = location.replace(/\"/g, \"%22\");\r\n  const html = `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`;\r\n  return send(event, html, MIMES.html);\r\n}\r\nfunction getResponseHeaders(event) {\r\n  return event.node.res.getHeaders();\r\n}\r\nfunction getResponseHeader(event, name) {\r\n  return event.node.res.getHeader(name);\r\n}\r\nfunction setResponseHeaders(event, headers) {\r\n  for (const [name, value] of Object.entries(headers)) {\r\n    event.node.res.setHeader(name, value);\r\n  }\r\n}\r\nconst setHeaders = setResponseHeaders;\r\nfunction setResponseHeader(event, name, value) {\r\n  event.node.res.setHeader(name, value);\r\n}\r\nconst setHeader = setResponseHeader;\r\nfunction appendResponseHeaders(event, headers) {\r\n  for (const [name, value] of Object.entries(headers)) {\r\n    appendResponseHeader(event, name, value);\r\n  }\r\n}\r\nconst appendHeaders = appendResponseHeaders;\r\nfunction appendResponseHeader(event, name, value) {\r\n  let current = event.node.res.getHeader(name);\r\n  if (!current) {\r\n    event.node.res.setHeader(name, value);\r\n    return;\r\n  }\r\n  if (!Array.isArray(current)) {\r\n    current = [current.toString()];\r\n  }\r\n  event.node.res.setHeader(name, [...current, value]);\r\n}\r\nconst appendHeader = appendResponseHeader;\r\nfunction clearResponseHeaders(event, headerNames) {\r\n  if (headerNames && headerNames.length > 0) {\r\n    for (const name of headerNames) {\r\n      removeResponseHeader(event, name);\r\n    }\r\n  } else {\r\n    for (const [name] of Object.entries(getResponseHeaders(event))) {\r\n      removeResponseHeader(event, name);\r\n    }\r\n  }\r\n}\r\nfunction removeResponseHeader(event, name) {\r\n  return event.node.res.removeHeader(name);\r\n}\r\nfunction isStream(data) {\r\n  if (!data || typeof data !== \"object\") {\r\n    return false;\r\n  }\r\n  if (typeof data.pipe === \"function\") {\r\n    if (typeof data._read === \"function\") {\r\n      return true;\r\n    }\r\n    if (typeof data.abort === \"function\") {\r\n      return true;\r\n    }\r\n  }\r\n  if (typeof data.pipeTo === \"function\") {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nfunction isWebResponse(data) {\r\n  return typeof Response !== \"undefined\" && data instanceof Response;\r\n}\r\nfunction sendStream(event, stream) {\r\n  if (!stream || typeof stream !== \"object\") {\r\n    throw new Error(\"[h3] Invalid stream provided.\");\r\n  }\r\n  event.node.res._data = stream;\r\n  if (!event.node.res.socket) {\r\n    event._handled = true;\r\n    return Promise.resolve();\r\n  }\r\n  if (hasProp(stream, \"pipeTo\") && typeof stream.pipeTo === \"function\") {\r\n    return stream.pipeTo(\r\n      new WritableStream({\r\n        write(chunk) {\r\n          event.node.res.write(chunk);\r\n        }\r\n      })\r\n    ).then(() => {\r\n      event.node.res.end();\r\n    });\r\n  }\r\n  if (hasProp(stream, \"pipe\") && typeof stream.pipe === \"function\") {\r\n    return new Promise((resolve, reject) => {\r\n      stream.pipe(event.node.res);\r\n      if (stream.on) {\r\n        stream.on(\"end\", () => {\r\n          event.node.res.end();\r\n          resolve();\r\n        });\r\n        stream.on(\"error\", (error) => {\r\n          reject(error);\r\n        });\r\n      }\r\n      event.node.res.on(\"close\", () => {\r\n        if (stream.abort) {\r\n          stream.abort();\r\n        }\r\n      });\r\n    });\r\n  }\r\n  throw new Error(\"[h3] Invalid or incompatible stream provided.\");\r\n}\r\nconst noop = () => {\r\n};\r\nfunction writeEarlyHints(event, hints, cb = noop) {\r\n  if (!event.node.res.socket) {\r\n    cb();\r\n    return;\r\n  }\r\n  if (typeof hints === \"string\" || Array.isArray(hints)) {\r\n    hints = { link: hints };\r\n  }\r\n  if (hints.link) {\r\n    hints.link = Array.isArray(hints.link) ? hints.link : hints.link.split(\",\");\r\n  }\r\n  const headers = Object.entries(hints).map(\r\n    (e) => [e[0].toLowerCase(), e[1]]\r\n  );\r\n  if (headers.length === 0) {\r\n    cb();\r\n    return;\r\n  }\r\n  let hint = \"HTTP/1.1 103 Early Hints\";\r\n  if (hints.link) {\r\n    hint += `\\r\r\nLink: ${hints.link.join(\", \")}`;\r\n  }\r\n  for (const [header, value] of headers) {\r\n    if (header === \"link\") {\r\n      continue;\r\n    }\r\n    hint += `\\r\r\n${header}: ${value}`;\r\n  }\r\n  if (event.node.res.socket) {\r\n    event.node.res.socket.write(\r\n      `${hint}\\r\r\n\\r\r\n`,\r\n      \"utf8\",\r\n      cb\r\n    );\r\n  } else {\r\n    cb();\r\n  }\r\n}\r\nfunction sendWebResponse(event, response) {\r\n  for (const [key, value] of response.headers) {\r\n    if (key === \"set-cookie\") {\r\n      event.node.res.appendHeader(key, splitCookiesString(value));\r\n    } else {\r\n      event.node.res.setHeader(key, value);\r\n    }\r\n  }\r\n  if (response.status) {\r\n    event.node.res.statusCode = sanitizeStatusCode(\r\n      response.status,\r\n      event.node.res.statusCode\r\n    );\r\n  }\r\n  if (response.statusText) {\r\n    event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\r\n  }\r\n  if (response.redirected) {\r\n    event.node.res.setHeader(\"location\", response.url);\r\n  }\r\n  if (!response.body) {\r\n    event.node.res.end();\r\n    return;\r\n  }\r\n  return sendStream(event, response.body);\r\n}\r\nfunction sendIterable(event, iterable, options) {\r\n  const serializer = options?.serializer ?? serializeIterableValue;\r\n  const iterator = coerceIterable(iterable);\r\n  return sendStream(\r\n    event,\r\n    new ReadableStream({\r\n      async pull(controller) {\r\n        const { value, done } = await iterator.next();\r\n        if (value !== void 0) {\r\n          const chunk = serializer(value);\r\n          if (chunk !== void 0) {\r\n            controller.enqueue(chunk);\r\n          }\r\n        }\r\n        if (done) {\r\n          controller.close();\r\n        }\r\n      },\r\n      cancel() {\r\n        iterator.return?.();\r\n      }\r\n    })\r\n  );\r\n}\r\n\r\nfunction resolveCorsOptions(options = {}) {\r\n  const defaultOptions = {\r\n    origin: \"*\",\r\n    methods: \"*\",\r\n    allowHeaders: \"*\",\r\n    exposeHeaders: \"*\",\r\n    credentials: false,\r\n    maxAge: false,\r\n    preflight: {\r\n      statusCode: 204\r\n    }\r\n  };\r\n  return defu(options, defaultOptions);\r\n}\r\nfunction isPreflightRequest(event) {\r\n  const origin = getRequestHeader(event, \"origin\");\r\n  const accessControlRequestMethod = getRequestHeader(\r\n    event,\r\n    \"access-control-request-method\"\r\n  );\r\n  return event.method === \"OPTIONS\" && !!origin && !!accessControlRequestMethod;\r\n}\r\nfunction isCorsOriginAllowed(origin, options) {\r\n  const { origin: originOption } = options;\r\n  if (!origin || !originOption || originOption === \"*\" || originOption === \"null\") {\r\n    return true;\r\n  }\r\n  if (Array.isArray(originOption)) {\r\n    return originOption.some((_origin) => {\r\n      if (_origin instanceof RegExp) {\r\n        return _origin.test(origin);\r\n      }\r\n      return origin === _origin;\r\n    });\r\n  }\r\n  return originOption(origin);\r\n}\r\nfunction createOriginHeaders(event, options) {\r\n  const { origin: originOption } = options;\r\n  const origin = getRequestHeader(event, \"origin\");\r\n  if (!origin || !originOption || originOption === \"*\") {\r\n    return { \"access-control-allow-origin\": \"*\" };\r\n  }\r\n  if (typeof originOption === \"string\") {\r\n    return { \"access-control-allow-origin\": originOption, vary: \"origin\" };\r\n  }\r\n  return isCorsOriginAllowed(origin, options) ? { \"access-control-allow-origin\": origin, vary: \"origin\" } : {};\r\n}\r\nfunction createMethodsHeaders(options) {\r\n  const { methods } = options;\r\n  if (!methods) {\r\n    return {};\r\n  }\r\n  if (methods === \"*\") {\r\n    return { \"access-control-allow-methods\": \"*\" };\r\n  }\r\n  return methods.length > 0 ? { \"access-control-allow-methods\": methods.join(\",\") } : {};\r\n}\r\nfunction createCredentialsHeaders(options) {\r\n  const { credentials } = options;\r\n  if (credentials) {\r\n    return { \"access-control-allow-credentials\": \"true\" };\r\n  }\r\n  return {};\r\n}\r\nfunction createAllowHeaderHeaders(event, options) {\r\n  const { allowHeaders } = options;\r\n  if (!allowHeaders || allowHeaders === \"*\" || allowHeaders.length === 0) {\r\n    const header = getRequestHeader(event, \"access-control-request-headers\");\r\n    return header ? {\r\n      \"access-control-allow-headers\": header,\r\n      vary: \"access-control-request-headers\"\r\n    } : {};\r\n  }\r\n  return {\r\n    \"access-control-allow-headers\": allowHeaders.join(\",\"),\r\n    vary: \"access-control-request-headers\"\r\n  };\r\n}\r\nfunction createExposeHeaders(options) {\r\n  const { exposeHeaders } = options;\r\n  if (!exposeHeaders) {\r\n    return {};\r\n  }\r\n  if (exposeHeaders === \"*\") {\r\n    return { \"access-control-expose-headers\": exposeHeaders };\r\n  }\r\n  return { \"access-control-expose-headers\": exposeHeaders.join(\",\") };\r\n}\r\nfunction appendCorsPreflightHeaders(event, options) {\r\n  appendHeaders(event, createOriginHeaders(event, options));\r\n  appendHeaders(event, createCredentialsHeaders(options));\r\n  appendHeaders(event, createExposeHeaders(options));\r\n  appendHeaders(event, createMethodsHeaders(options));\r\n  appendHeaders(event, createAllowHeaderHeaders(event, options));\r\n}\r\nfunction appendCorsHeaders(event, options) {\r\n  appendHeaders(event, createOriginHeaders(event, options));\r\n  appendHeaders(event, createCredentialsHeaders(options));\r\n  appendHeaders(event, createExposeHeaders(options));\r\n}\r\n\r\nfunction handleCors(event, options) {\r\n  const _options = resolveCorsOptions(options);\r\n  if (isPreflightRequest(event)) {\r\n    appendCorsPreflightHeaders(event, options);\r\n    sendNoContent(event, _options.preflight.statusCode);\r\n    return true;\r\n  }\r\n  appendCorsHeaders(event, options);\r\n  return false;\r\n}\r\n\r\nasync function getRequestFingerprint(event, opts = {}) {\r\n  const fingerprint = [];\r\n  if (opts.ip !== false) {\r\n    fingerprint.push(\r\n      getRequestIP(event, { xForwardedFor: opts.xForwardedFor })\r\n    );\r\n  }\r\n  if (opts.method === true) {\r\n    fingerprint.push(event.method);\r\n  }\r\n  if (opts.path === true) {\r\n    fingerprint.push(event.path);\r\n  }\r\n  if (opts.userAgent === true) {\r\n    fingerprint.push(getRequestHeader(event, \"user-agent\"));\r\n  }\r\n  const fingerprintString = fingerprint.filter(Boolean).join(\"|\");\r\n  if (!fingerprintString) {\r\n    return null;\r\n  }\r\n  if (opts.hash === false) {\r\n    return fingerprintString;\r\n  }\r\n  const buffer = await crypto.subtle.digest(\r\n    opts.hash || \"SHA-1\",\r\n    new TextEncoder().encode(fingerprintString)\r\n  );\r\n  const hash = [...new Uint8Array(buffer)].map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\r\n  return hash;\r\n}\r\n\r\nconst PayloadMethods = /* @__PURE__ */ new Set([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"]);\r\nconst ignoredHeaders = /* @__PURE__ */ new Set([\r\n  \"transfer-encoding\",\r\n  \"connection\",\r\n  \"keep-alive\",\r\n  \"upgrade\",\r\n  \"expect\",\r\n  \"host\",\r\n  \"accept\"\r\n]);\r\nasync function proxyRequest(event, target, opts = {}) {\r\n  let body;\r\n  let duplex;\r\n  if (PayloadMethods.has(event.method)) {\r\n    if (opts.streamRequest) {\r\n      body = getRequestWebStream(event);\r\n      duplex = \"half\";\r\n    } else {\r\n      body = await readRawBody(event, false).catch(() => void 0);\r\n    }\r\n  }\r\n  const method = opts.fetchOptions?.method || event.method;\r\n  const fetchHeaders = mergeHeaders(\r\n    getProxyRequestHeaders(event),\r\n    opts.fetchOptions?.headers,\r\n    opts.headers\r\n  );\r\n  return sendProxy(event, target, {\r\n    ...opts,\r\n    fetchOptions: {\r\n      method,\r\n      body,\r\n      duplex,\r\n      ...opts.fetchOptions,\r\n      headers: fetchHeaders\r\n    }\r\n  });\r\n}\r\nasync function sendProxy(event, target, opts = {}) {\r\n  const response = await _getFetch(opts.fetch)(target, {\r\n    headers: opts.headers,\r\n    ignoreResponseError: true,\r\n    // make $ofetch.raw transparent\r\n    ...opts.fetchOptions\r\n  });\r\n  event.node.res.statusCode = sanitizeStatusCode(\r\n    response.status,\r\n    event.node.res.statusCode\r\n  );\r\n  event.node.res.statusMessage = sanitizeStatusMessage(response.statusText);\r\n  const cookies = [];\r\n  for (const [key, value] of response.headers.entries()) {\r\n    if (key === \"content-encoding\") {\r\n      continue;\r\n    }\r\n    if (key === \"content-length\") {\r\n      continue;\r\n    }\r\n    if (key === \"set-cookie\") {\r\n      cookies.push(...splitCookiesString(value));\r\n      continue;\r\n    }\r\n    event.node.res.setHeader(key, value);\r\n  }\r\n  if (cookies.length > 0) {\r\n    event.node.res.setHeader(\r\n      \"set-cookie\",\r\n      cookies.map((cookie) => {\r\n        if (opts.cookieDomainRewrite) {\r\n          cookie = rewriteCookieProperty(\r\n            cookie,\r\n            opts.cookieDomainRewrite,\r\n            \"domain\"\r\n          );\r\n        }\r\n        if (opts.cookiePathRewrite) {\r\n          cookie = rewriteCookieProperty(\r\n            cookie,\r\n            opts.cookiePathRewrite,\r\n            \"path\"\r\n          );\r\n        }\r\n        return cookie;\r\n      })\r\n    );\r\n  }\r\n  if (opts.onResponse) {\r\n    await opts.onResponse(event, response);\r\n  }\r\n  if (response._data !== void 0) {\r\n    return response._data;\r\n  }\r\n  if (event.handled) {\r\n    return;\r\n  }\r\n  if (opts.sendStream === false) {\r\n    const data = new Uint8Array(await response.arrayBuffer());\r\n    return event.node.res.end(data);\r\n  }\r\n  if (response.body) {\r\n    for await (const chunk of response.body) {\r\n      event.node.res.write(chunk);\r\n    }\r\n  }\r\n  return event.node.res.end();\r\n}\r\nfunction getProxyRequestHeaders(event) {\r\n  const headers = /* @__PURE__ */ Object.create(null);\r\n  const reqHeaders = getRequestHeaders(event);\r\n  for (const name in reqHeaders) {\r\n    if (!ignoredHeaders.has(name)) {\r\n      headers[name] = reqHeaders[name];\r\n    }\r\n  }\r\n  return headers;\r\n}\r\nfunction fetchWithEvent(event, req, init, options) {\r\n  return _getFetch(options?.fetch)(req, {\r\n    ...init,\r\n    context: init?.context || event.context,\r\n    headers: {\r\n      ...getProxyRequestHeaders(event),\r\n      ...init?.headers\r\n    }\r\n  });\r\n}\r\nfunction _getFetch(_fetch) {\r\n  if (_fetch) {\r\n    return _fetch;\r\n  }\r\n  if (globalThis.fetch) {\r\n    return globalThis.fetch;\r\n  }\r\n  throw new Error(\r\n    \"fetch is not available. Try importing `node-fetch-native/polyfill` for Node.js.\"\r\n  );\r\n}\r\nfunction rewriteCookieProperty(header, map, property) {\r\n  const _map = typeof map === \"string\" ? { \"*\": map } : map;\r\n  return header.replace(\r\n    new RegExp(`(;\\\\s*${property}=)([^;]+)`, \"gi\"),\r\n    (match, prefix, previousValue) => {\r\n      let newValue;\r\n      if (previousValue in _map) {\r\n        newValue = _map[previousValue];\r\n      } else if (\"*\" in _map) {\r\n        newValue = _map[\"*\"];\r\n      } else {\r\n        return match;\r\n      }\r\n      return newValue ? prefix + newValue : \"\";\r\n    }\r\n  );\r\n}\r\nfunction mergeHeaders(defaults, ...inputs) {\r\n  const _inputs = inputs.filter(Boolean);\r\n  if (_inputs.length === 0) {\r\n    return defaults;\r\n  }\r\n  const merged = new Headers(defaults);\r\n  for (const input of _inputs) {\r\n    for (const [key, value] of Object.entries(input)) {\r\n      if (value !== void 0) {\r\n        merged.set(key, value);\r\n      }\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\nconst getSessionPromise = Symbol(\"getSession\");\r\nconst DEFAULT_NAME = \"h3\";\r\nconst DEFAULT_COOKIE = {\r\n  path: \"/\",\r\n  secure: true,\r\n  httpOnly: true\r\n};\r\nasync function useSession(event, config) {\r\n  const sessionName = config.name || DEFAULT_NAME;\r\n  await getSession(event, config);\r\n  const sessionManager = {\r\n    get id() {\r\n      return event.context.sessions?.[sessionName]?.id;\r\n    },\r\n    get data() {\r\n      return event.context.sessions?.[sessionName]?.data || {};\r\n    },\r\n    update: async (update) => {\r\n      await updateSession(event, config, update);\r\n      return sessionManager;\r\n    },\r\n    clear: async () => {\r\n      await clearSession(event, config);\r\n      return sessionManager;\r\n    }\r\n  };\r\n  return sessionManager;\r\n}\r\nasync function getSession(event, config) {\r\n  const sessionName = config.name || DEFAULT_NAME;\r\n  if (!event.context.sessions) {\r\n    event.context.sessions = /* @__PURE__ */ Object.create(null);\r\n  }\r\n  const existingSession = event.context.sessions[sessionName];\r\n  if (existingSession) {\r\n    return existingSession[getSessionPromise] || existingSession;\r\n  }\r\n  const session = {\r\n    id: \"\",\r\n    createdAt: 0,\r\n    data: /* @__PURE__ */ Object.create(null)\r\n  };\r\n  event.context.sessions[sessionName] = session;\r\n  let sealedSession;\r\n  if (config.sessionHeader !== false) {\r\n    const headerName = typeof config.sessionHeader === \"string\" ? config.sessionHeader.toLowerCase() : `x-${sessionName.toLowerCase()}-session`;\r\n    const headerValue = event.node.req.headers[headerName];\r\n    if (typeof headerValue === \"string\") {\r\n      sealedSession = headerValue;\r\n    }\r\n  }\r\n  if (!sealedSession) {\r\n    sealedSession = getCookie(event, sessionName);\r\n  }\r\n  if (sealedSession) {\r\n    const promise = unsealSession(event, config, sealedSession).catch(() => {\r\n    }).then((unsealed) => {\r\n      Object.assign(session, unsealed);\r\n      delete event.context.sessions[sessionName][getSessionPromise];\r\n      return session;\r\n    });\r\n    event.context.sessions[sessionName][getSessionPromise] = promise;\r\n    await promise;\r\n  }\r\n  if (!session.id) {\r\n    session.id = config.generateId?.() ?? (config.crypto || crypto).randomUUID();\r\n    session.createdAt = Date.now();\r\n    await updateSession(event, config);\r\n  }\r\n  return session;\r\n}\r\nasync function updateSession(event, config, update) {\r\n  const sessionName = config.name || DEFAULT_NAME;\r\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\r\n  if (typeof update === \"function\") {\r\n    update = update(session.data);\r\n  }\r\n  if (update) {\r\n    Object.assign(session.data, update);\r\n  }\r\n  if (config.cookie !== false) {\r\n    const sealed = await sealSession(event, config);\r\n    setCookie(event, sessionName, sealed, {\r\n      ...DEFAULT_COOKIE,\r\n      expires: config.maxAge ? new Date(session.createdAt + config.maxAge * 1e3) : void 0,\r\n      ...config.cookie\r\n    });\r\n  }\r\n  return session;\r\n}\r\nasync function sealSession(event, config) {\r\n  const sessionName = config.name || DEFAULT_NAME;\r\n  const session = event.context.sessions?.[sessionName] || await getSession(event, config);\r\n  const sealed = await seal(config.crypto || crypto, session, config.password, {\r\n    ...defaults,\r\n    ttl: config.maxAge ? config.maxAge * 1e3 : 0,\r\n    ...config.seal\r\n  });\r\n  return sealed;\r\n}\r\nasync function unsealSession(_event, config, sealed) {\r\n  const unsealed = await unseal(\r\n    config.crypto || crypto,\r\n    sealed,\r\n    config.password,\r\n    {\r\n      ...defaults,\r\n      ttl: config.maxAge ? config.maxAge * 1e3 : 0,\r\n      ...config.seal\r\n    }\r\n  );\r\n  if (config.maxAge) {\r\n    const age = Date.now() - (unsealed.createdAt || Number.NEGATIVE_INFINITY);\r\n    if (age > config.maxAge * 1e3) {\r\n      throw new Error(\"Session expired!\");\r\n    }\r\n  }\r\n  return unsealed;\r\n}\r\nasync function clearSession(event, config) {\r\n  const sessionName = config.name || DEFAULT_NAME;\r\n  if (event.context.sessions?.[sessionName]) {\r\n    delete event.context.sessions[sessionName];\r\n  }\r\n  await setCookie(event, sessionName, \"\", {\r\n    ...DEFAULT_COOKIE,\r\n    ...config.cookie\r\n  });\r\n}\r\n\r\nfunction formatEventStreamMessage(message) {\r\n  let result = \"\";\r\n  if (message.id) {\r\n    result += `id: ${message.id}\r\n`;\r\n  }\r\n  if (message.event) {\r\n    result += `event: ${message.event}\r\n`;\r\n  }\r\n  if (typeof message.retry === \"number\" && Number.isInteger(message.retry)) {\r\n    result += `retry: ${message.retry}\r\n`;\r\n  }\r\n  result += `data: ${message.data}\r\n\r\n`;\r\n  return result;\r\n}\r\nfunction formatEventStreamMessages(messages) {\r\n  let result = \"\";\r\n  for (const msg of messages) {\r\n    result += formatEventStreamMessage(msg);\r\n  }\r\n  return result;\r\n}\r\nfunction setEventStreamHeaders(event) {\r\n  const headers = {\r\n    \"Content-Type\": \"text/event-stream\",\r\n    \"Cache-Control\": \"private, no-cache, no-store, no-transform, must-revalidate, max-age=0\",\r\n    \"X-Accel-Buffering\": \"no\"\r\n    // prevent nginx from buffering the response\r\n  };\r\n  if (!isHttp2Request(event)) {\r\n    headers.Connection = \"keep-alive\";\r\n  }\r\n  setResponseHeaders(event, headers);\r\n}\r\nfunction isHttp2Request(event) {\r\n  return getHeader(event, \":path\") !== void 0 && getHeader(event, \":method\") !== void 0;\r\n}\r\n\r\nvar __defProp$1 = Object.defineProperty;\r\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __publicField$1 = (obj, key, value) => {\r\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\r\n  return value;\r\n};\r\nclass EventStream {\r\n  constructor(event, opts = {}) {\r\n    __publicField$1(this, \"_h3Event\");\r\n    __publicField$1(this, \"_transformStream\", new TransformStream());\r\n    __publicField$1(this, \"_writer\");\r\n    __publicField$1(this, \"_encoder\", new TextEncoder());\r\n    __publicField$1(this, \"_writerIsClosed\", false);\r\n    __publicField$1(this, \"_paused\", false);\r\n    __publicField$1(this, \"_unsentData\");\r\n    __publicField$1(this, \"_disposed\", false);\r\n    __publicField$1(this, \"_handled\", false);\r\n    this._h3Event = event;\r\n    this._writer = this._transformStream.writable.getWriter();\r\n    this._writer.closed.then(() => {\r\n      this._writerIsClosed = true;\r\n    });\r\n    if (opts.autoclose !== false) {\r\n      this._h3Event.node.req.on(\"close\", () => this.close());\r\n    }\r\n  }\r\n  async push(message) {\r\n    if (typeof message === \"string\") {\r\n      await this._sendEvent({ data: message });\r\n      return;\r\n    }\r\n    if (Array.isArray(message)) {\r\n      if (message.length === 0) {\r\n        return;\r\n      }\r\n      if (typeof message[0] === \"string\") {\r\n        const msgs = [];\r\n        for (const item of message) {\r\n          msgs.push({ data: item });\r\n        }\r\n        await this._sendEvents(msgs);\r\n        return;\r\n      }\r\n      await this._sendEvents(message);\r\n      return;\r\n    }\r\n    await this._sendEvent(message);\r\n  }\r\n  async _sendEvent(message) {\r\n    if (this._writerIsClosed) {\r\n      return;\r\n    }\r\n    if (this._paused && !this._unsentData) {\r\n      this._unsentData = formatEventStreamMessage(message);\r\n      return;\r\n    }\r\n    if (this._paused) {\r\n      this._unsentData += formatEventStreamMessage(message);\r\n      return;\r\n    }\r\n    await this._writer.write(this._encoder.encode(formatEventStreamMessage(message))).catch();\r\n  }\r\n  async _sendEvents(messages) {\r\n    if (this._writerIsClosed) {\r\n      return;\r\n    }\r\n    const payload = formatEventStreamMessages(messages);\r\n    if (this._paused && !this._unsentData) {\r\n      this._unsentData = payload;\r\n      return;\r\n    }\r\n    if (this._paused) {\r\n      this._unsentData += payload;\r\n      return;\r\n    }\r\n    await this._writer.write(this._encoder.encode(payload)).catch();\r\n  }\r\n  pause() {\r\n    this._paused = true;\r\n  }\r\n  get isPaused() {\r\n    return this._paused;\r\n  }\r\n  async resume() {\r\n    this._paused = false;\r\n    await this.flush();\r\n  }\r\n  async flush() {\r\n    if (this._writerIsClosed) {\r\n      return;\r\n    }\r\n    if (this._unsentData?.length) {\r\n      await this._writer.write(this._encoder.encode(this._unsentData));\r\n      this._unsentData = void 0;\r\n    }\r\n  }\r\n  /**\r\n   * Close the stream and the connection if the stream is being sent to the client\r\n   */\r\n  async close() {\r\n    if (this._disposed) {\r\n      return;\r\n    }\r\n    if (!this._writerIsClosed) {\r\n      try {\r\n        await this._writer.close();\r\n      } catch {\r\n      }\r\n    }\r\n    if (this._h3Event._handled && this._handled && !this._h3Event.node.res.closed) {\r\n      this._h3Event.node.res.end();\r\n    }\r\n    this._disposed = true;\r\n  }\r\n  /**\r\n   * Triggers callback when the writable stream is closed.\r\n   * It is also triggered after calling the `close()` method.\r\n   * It also triggers when the request connection has been closed by either the client or the server.\r\n   */\r\n  onClosed(cb) {\r\n    this._writer.closed.then(cb);\r\n    this._h3Event.node?.req.on(\"close\", cb);\r\n  }\r\n  async send() {\r\n    setEventStreamHeaders(this._h3Event);\r\n    setResponseStatus(this._h3Event, 200);\r\n    this._h3Event._handled = true;\r\n    this._handled = true;\r\n    await sendStream(this._h3Event, this._transformStream.readable);\r\n  }\r\n}\r\n\r\nfunction createEventStream(event, opts) {\r\n  return new EventStream(event, opts);\r\n}\r\n\r\nasync function serveStatic(event, options) {\r\n  if (event.method !== \"GET\" && event.method !== \"HEAD\") {\r\n    if (!options.fallthrough) {\r\n      throw createError({\r\n        statusMessage: \"Method Not Allowed\",\r\n        statusCode: 405\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n  const originalId = decodePath(\r\n    withLeadingSlash(withoutTrailingSlash(parseURL(event.path).pathname))\r\n  );\r\n  const acceptEncodings = parseAcceptEncoding(\r\n    getRequestHeader(event, \"accept-encoding\"),\r\n    options.encodings\r\n  );\r\n  if (acceptEncodings.length > 1) {\r\n    setResponseHeader(event, \"vary\", \"accept-encoding\");\r\n  }\r\n  let id = originalId;\r\n  let meta;\r\n  const _ids = idSearchPaths(\r\n    originalId,\r\n    acceptEncodings,\r\n    options.indexNames || [\"/index.html\"]\r\n  );\r\n  for (const _id of _ids) {\r\n    const _meta = await options.getMeta(_id);\r\n    if (_meta) {\r\n      meta = _meta;\r\n      id = _id;\r\n      break;\r\n    }\r\n  }\r\n  if (!meta) {\r\n    if (!options.fallthrough) {\r\n      throw createError({\r\n        statusMessage: \"Cannot find static asset \" + id,\r\n        statusCode: 404\r\n      });\r\n    }\r\n    return false;\r\n  }\r\n  if (meta.etag && !getResponseHeader(event, \"etag\")) {\r\n    setResponseHeader(event, \"etag\", meta.etag);\r\n  }\r\n  const ifNotMatch = meta.etag && getRequestHeader(event, \"if-none-match\") === meta.etag;\r\n  if (ifNotMatch) {\r\n    setResponseStatus(event, 304, \"Not Modified\");\r\n    return send(event, \"\");\r\n  }\r\n  if (meta.mtime) {\r\n    const mtimeDate = new Date(meta.mtime);\r\n    const ifModifiedSinceH = getRequestHeader(event, \"if-modified-since\");\r\n    if (ifModifiedSinceH && new Date(ifModifiedSinceH) >= mtimeDate) {\r\n      setResponseStatus(event, 304, \"Not Modified\");\r\n      return send(event, null);\r\n    }\r\n    if (!getResponseHeader(event, \"last-modified\")) {\r\n      setResponseHeader(event, \"last-modified\", mtimeDate.toUTCString());\r\n    }\r\n  }\r\n  if (meta.type && !getResponseHeader(event, \"content-type\")) {\r\n    setResponseHeader(event, \"content-type\", meta.type);\r\n  }\r\n  if (meta.encoding && !getResponseHeader(event, \"content-encoding\")) {\r\n    setResponseHeader(event, \"content-encoding\", meta.encoding);\r\n  }\r\n  if (meta.size !== void 0 && meta.size > 0 && !getResponseHeader(event, \"content-length\")) {\r\n    setResponseHeader(event, \"content-length\", meta.size);\r\n  }\r\n  if (event.method === \"HEAD\") {\r\n    return send(event, null);\r\n  }\r\n  const contents = await options.getContents(id);\r\n  return isStream(contents) ? sendStream(event, contents) : send(event, contents);\r\n}\r\nfunction parseAcceptEncoding(header, encodingMap) {\r\n  if (!encodingMap || !header) {\r\n    return [];\r\n  }\r\n  return String(header || \"\").split(\",\").map((e) => encodingMap[e.trim()]).filter(Boolean);\r\n}\r\nfunction idSearchPaths(id, encodings, indexNames) {\r\n  const ids = [];\r\n  for (const suffix of [\"\", ...indexNames]) {\r\n    for (const encoding of [...encodings, \"\"]) {\r\n      ids.push(`${id}${suffix}${encoding}`);\r\n    }\r\n  }\r\n  return ids;\r\n}\r\n\r\nfunction defineWebSocket(hooks) {\r\n  return hooks;\r\n}\r\nfunction defineWebSocketHandler(hooks) {\r\n  return defineEventHandler({\r\n    handler() {\r\n      throw createError({\r\n        statusCode: 426,\r\n        statusMessage: \"Upgrade Required\"\r\n      });\r\n    },\r\n    websocket: hooks\r\n  });\r\n}\r\n\r\nvar __defProp = Object.defineProperty;\r\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __publicField = (obj, key, value) => {\r\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\r\n  return value;\r\n};\r\nclass H3Event {\r\n  constructor(req, res) {\r\n    __publicField(this, \"__is_event__\", true);\r\n    // Context\r\n    __publicField(this, \"node\");\r\n    // Node\r\n    __publicField(this, \"web\");\r\n    // Web\r\n    __publicField(this, \"context\", {});\r\n    // Shared\r\n    // Request\r\n    __publicField(this, \"_method\");\r\n    __publicField(this, \"_path\");\r\n    __publicField(this, \"_headers\");\r\n    __publicField(this, \"_requestBody\");\r\n    // Response\r\n    __publicField(this, \"_handled\", false);\r\n    this.node = { req, res };\r\n  }\r\n  // --- Request ---\r\n  get method() {\r\n    if (!this._method) {\r\n      this._method = (this.node.req.method || \"GET\").toUpperCase();\r\n    }\r\n    return this._method;\r\n  }\r\n  get path() {\r\n    return this._path || this.node.req.url || \"/\";\r\n  }\r\n  get headers() {\r\n    if (!this._headers) {\r\n      this._headers = _normalizeNodeHeaders(this.node.req.headers);\r\n    }\r\n    return this._headers;\r\n  }\r\n  // --- Respoonse ---\r\n  get handled() {\r\n    return this._handled || this.node.res.writableEnded || this.node.res.headersSent;\r\n  }\r\n  respondWith(response) {\r\n    return Promise.resolve(response).then(\r\n      (_response) => sendWebResponse(this, _response)\r\n    );\r\n  }\r\n  // --- Utils ---\r\n  toString() {\r\n    return `[${this.method}] ${this.path}`;\r\n  }\r\n  toJSON() {\r\n    return this.toString();\r\n  }\r\n  // --- Deprecated ---\r\n  /** @deprecated Please use `event.node.req` instead. **/\r\n  get req() {\r\n    return this.node.req;\r\n  }\r\n  /** @deprecated Please use `event.node.res` instead. **/\r\n  get res() {\r\n    return this.node.res;\r\n  }\r\n}\r\nfunction isEvent(input) {\r\n  return hasProp(input, \"__is_event__\");\r\n}\r\nfunction createEvent(req, res) {\r\n  return new H3Event(req, res);\r\n}\r\nfunction _normalizeNodeHeaders(nodeHeaders) {\r\n  const headers = new Headers();\r\n  for (const [name, value] of Object.entries(nodeHeaders)) {\r\n    if (Array.isArray(value)) {\r\n      for (const item of value) {\r\n        headers.append(name, item);\r\n      }\r\n    } else if (value) {\r\n      headers.set(name, value);\r\n    }\r\n  }\r\n  return headers;\r\n}\r\n\r\nfunction defineEventHandler(handler) {\r\n  if (typeof handler === \"function\") {\r\n    handler.__is_handler__ = true;\r\n    return handler;\r\n  }\r\n  const _hooks = {\r\n    onRequest: _normalizeArray(handler.onRequest),\r\n    onBeforeResponse: _normalizeArray(handler.onBeforeResponse)\r\n  };\r\n  const _handler = (event) => {\r\n    return _callHandler(event, handler.handler, _hooks);\r\n  };\r\n  _handler.__is_handler__ = true;\r\n  _handler.__resolve__ = handler.handler.__resolve__;\r\n  _handler.__websocket__ = handler.websocket;\r\n  return _handler;\r\n}\r\nfunction _normalizeArray(input) {\r\n  return input ? Array.isArray(input) ? input : [input] : void 0;\r\n}\r\nasync function _callHandler(event, handler, hooks) {\r\n  if (hooks.onRequest) {\r\n    for (const hook of hooks.onRequest) {\r\n      await hook(event);\r\n      if (event.handled) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n  const body = await handler(event);\r\n  const response = { body };\r\n  if (hooks.onBeforeResponse) {\r\n    for (const hook of hooks.onBeforeResponse) {\r\n      await hook(event, response);\r\n    }\r\n  }\r\n  return response.body;\r\n}\r\nconst eventHandler = defineEventHandler;\r\nfunction defineRequestMiddleware(fn) {\r\n  return fn;\r\n}\r\nfunction defineResponseMiddleware(fn) {\r\n  return fn;\r\n}\r\nfunction isEventHandler(input) {\r\n  return hasProp(input, \"__is_handler__\");\r\n}\r\nfunction toEventHandler(input, _, _route) {\r\n  if (!isEventHandler(input)) {\r\n    console.warn(\r\n      \"[h3] Implicit event handler conversion is deprecated. Use `eventHandler()` or `fromNodeMiddleware()` to define event handlers.\",\r\n      _route && _route !== \"/\" ? `\r\n     Route: ${_route}` : \"\",\r\n      `\r\n     Handler: ${input}`\r\n    );\r\n  }\r\n  return input;\r\n}\r\nfunction dynamicEventHandler(initial) {\r\n  let current = initial;\r\n  const wrapper = eventHandler((event) => {\r\n    if (current) {\r\n      return current(event);\r\n    }\r\n  });\r\n  wrapper.set = (handler) => {\r\n    current = handler;\r\n  };\r\n  return wrapper;\r\n}\r\nfunction defineLazyEventHandler(factory) {\r\n  let _promise;\r\n  let _resolved;\r\n  const resolveHandler = () => {\r\n    if (_resolved) {\r\n      return Promise.resolve(_resolved);\r\n    }\r\n    if (!_promise) {\r\n      _promise = Promise.resolve(factory()).then((r) => {\r\n        const handler2 = r.default || r;\r\n        if (typeof handler2 !== \"function\") {\r\n          throw new TypeError(\r\n            \"Invalid lazy handler result. It should be a function:\",\r\n            handler2\r\n          );\r\n        }\r\n        _resolved = { handler: toEventHandler(r.default || r) };\r\n        return _resolved;\r\n      });\r\n    }\r\n    return _promise;\r\n  };\r\n  const handler = eventHandler((event) => {\r\n    if (_resolved) {\r\n      return _resolved.handler(event);\r\n    }\r\n    return resolveHandler().then((r) => r.handler(event));\r\n  });\r\n  handler.__resolve__ = resolveHandler;\r\n  return handler;\r\n}\r\nconst lazyEventHandler = defineLazyEventHandler;\r\n\r\nconst H3Headers = globalThis.Headers;\r\nconst H3Response = globalThis.Response;\r\n\r\nfunction createApp(options = {}) {\r\n  const stack = [];\r\n  const handler = createAppEventHandler(stack, options);\r\n  const resolve = createResolver(stack);\r\n  handler.__resolve__ = resolve;\r\n  const getWebsocket = cachedFn(() => websocketOptions(resolve, options));\r\n  const app = {\r\n    // @ts-expect-error\r\n    use: (arg1, arg2, arg3) => use(app, arg1, arg2, arg3),\r\n    resolve,\r\n    handler,\r\n    stack,\r\n    options,\r\n    get websocket() {\r\n      return getWebsocket();\r\n    }\r\n  };\r\n  return app;\r\n}\r\nfunction use(app, arg1, arg2, arg3) {\r\n  if (Array.isArray(arg1)) {\r\n    for (const i of arg1) {\r\n      use(app, i, arg2, arg3);\r\n    }\r\n  } else if (Array.isArray(arg2)) {\r\n    for (const i of arg2) {\r\n      use(app, arg1, i, arg3);\r\n    }\r\n  } else if (typeof arg1 === \"string\") {\r\n    app.stack.push(\r\n      normalizeLayer({ ...arg3, route: arg1, handler: arg2 })\r\n    );\r\n  } else if (typeof arg1 === \"function\") {\r\n    app.stack.push(normalizeLayer({ ...arg2, handler: arg1 }));\r\n  } else {\r\n    app.stack.push(normalizeLayer({ ...arg1 }));\r\n  }\r\n  return app;\r\n}\r\nfunction createAppEventHandler(stack, options) {\r\n  const spacing = options.debug ? 2 : void 0;\r\n  return eventHandler(async (event) => {\r\n    event.node.req.originalUrl = event.node.req.originalUrl || event.node.req.url || \"/\";\r\n    const _reqPath = event._path || event.node.req.url || \"/\";\r\n    let _layerPath;\r\n    if (options.onRequest) {\r\n      await options.onRequest(event);\r\n    }\r\n    for (const layer of stack) {\r\n      if (layer.route.length > 1) {\r\n        if (!_reqPath.startsWith(layer.route)) {\r\n          continue;\r\n        }\r\n        _layerPath = _reqPath.slice(layer.route.length) || \"/\";\r\n      } else {\r\n        _layerPath = _reqPath;\r\n      }\r\n      if (layer.match && !layer.match(_layerPath, event)) {\r\n        continue;\r\n      }\r\n      event._path = _layerPath;\r\n      event.node.req.url = _layerPath;\r\n      const val = await layer.handler(event);\r\n      const _body = val === void 0 ? void 0 : await val;\r\n      if (_body !== void 0) {\r\n        const _response = { body: _body };\r\n        if (options.onBeforeResponse) {\r\n          await options.onBeforeResponse(event, _response);\r\n        }\r\n        await handleHandlerResponse(event, _response.body, spacing);\r\n        if (options.onAfterResponse) {\r\n          await options.onAfterResponse(event, _response);\r\n        }\r\n        return;\r\n      }\r\n      if (event.handled) {\r\n        if (options.onAfterResponse) {\r\n          await options.onAfterResponse(event, void 0);\r\n        }\r\n        return;\r\n      }\r\n    }\r\n    if (!event.handled) {\r\n      throw createError({\r\n        statusCode: 404,\r\n        statusMessage: `Cannot find any path matching ${event.path || \"/\"}.`\r\n      });\r\n    }\r\n    if (options.onAfterResponse) {\r\n      await options.onAfterResponse(event, void 0);\r\n    }\r\n  });\r\n}\r\nfunction createResolver(stack) {\r\n  return async (path) => {\r\n    let _layerPath;\r\n    for (const layer of stack) {\r\n      if (layer.route === \"/\" && !layer.handler.__resolve__) {\r\n        continue;\r\n      }\r\n      if (!path.startsWith(layer.route)) {\r\n        continue;\r\n      }\r\n      _layerPath = path.slice(layer.route.length) || \"/\";\r\n      if (layer.match && !layer.match(_layerPath, void 0)) {\r\n        continue;\r\n      }\r\n      let res = { route: layer.route, handler: layer.handler };\r\n      if (res.handler.__resolve__) {\r\n        const _res = await res.handler.__resolve__(_layerPath);\r\n        if (!_res) {\r\n          continue;\r\n        }\r\n        res = {\r\n          ...res,\r\n          ..._res,\r\n          route: joinURL(res.route || \"/\", _res.route || \"/\")\r\n        };\r\n      }\r\n      return res;\r\n    }\r\n  };\r\n}\r\nfunction normalizeLayer(input) {\r\n  let handler = input.handler;\r\n  if (handler.handler) {\r\n    handler = handler.handler;\r\n  }\r\n  if (input.lazy) {\r\n    handler = lazyEventHandler(handler);\r\n  } else if (!isEventHandler(handler)) {\r\n    handler = toEventHandler(handler, void 0, input.route);\r\n  }\r\n  return {\r\n    route: withoutTrailingSlash(input.route),\r\n    match: input.match,\r\n    handler\r\n  };\r\n}\r\nfunction handleHandlerResponse(event, val, jsonSpace) {\r\n  if (val === null) {\r\n    return sendNoContent(event);\r\n  }\r\n  if (val) {\r\n    if (isWebResponse(val)) {\r\n      return sendWebResponse(event, val);\r\n    }\r\n    if (isStream(val)) {\r\n      return sendStream(event, val);\r\n    }\r\n    if (val.buffer) {\r\n      return send(event, val);\r\n    }\r\n    if (val.arrayBuffer && typeof val.arrayBuffer === \"function\") {\r\n      return val.arrayBuffer().then((arrayBuffer) => {\r\n        return send(event, Buffer.from(arrayBuffer), val.type);\r\n      });\r\n    }\r\n    if (val instanceof Error) {\r\n      throw createError(val);\r\n    }\r\n    if (typeof val.end === \"function\") {\r\n      return true;\r\n    }\r\n  }\r\n  const valType = typeof val;\r\n  if (valType === \"string\") {\r\n    return send(event, val, MIMES.html);\r\n  }\r\n  if (valType === \"object\" || valType === \"boolean\" || valType === \"number\") {\r\n    return send(event, JSON.stringify(val, void 0, jsonSpace), MIMES.json);\r\n  }\r\n  if (valType === \"bigint\") {\r\n    return send(event, val.toString(), MIMES.json);\r\n  }\r\n  throw createError({\r\n    statusCode: 500,\r\n    statusMessage: `[h3] Cannot send ${valType} as response.`\r\n  });\r\n}\r\nfunction cachedFn(fn) {\r\n  let cache;\r\n  return () => {\r\n    if (!cache) {\r\n      cache = fn();\r\n    }\r\n    return cache;\r\n  };\r\n}\r\nfunction websocketOptions(evResolver, appOptions) {\r\n  return {\r\n    ...appOptions.websocket,\r\n    async resolve(info) {\r\n      const { pathname } = parseURL(info.url || \"/\");\r\n      const resolved = await evResolver(pathname);\r\n      return resolved?.handler?.__websocket__ || {};\r\n    }\r\n  };\r\n}\r\n\r\nconst RouterMethods = [\r\n  \"connect\",\r\n  \"delete\",\r\n  \"get\",\r\n  \"head\",\r\n  \"options\",\r\n  \"post\",\r\n  \"put\",\r\n  \"trace\",\r\n  \"patch\"\r\n];\r\nfunction createRouter(opts = {}) {\r\n  const _router = createRouter$1({});\r\n  const routes = {};\r\n  let _matcher;\r\n  const router = {};\r\n  const addRoute = (path, handler, method) => {\r\n    let route = routes[path];\r\n    if (!route) {\r\n      routes[path] = route = { path, handlers: {} };\r\n      _router.insert(path, route);\r\n    }\r\n    if (Array.isArray(method)) {\r\n      for (const m of method) {\r\n        addRoute(path, handler, m);\r\n      }\r\n    } else {\r\n      route.handlers[method] = toEventHandler(handler, void 0, path);\r\n    }\r\n    return router;\r\n  };\r\n  router.use = router.add = (path, handler, method) => addRoute(path, handler, method || \"all\");\r\n  for (const method of RouterMethods) {\r\n    router[method] = (path, handle) => router.add(path, handle, method);\r\n  }\r\n  const matchHandler = (path = \"/\", method = \"get\") => {\r\n    const qIndex = path.indexOf(\"?\");\r\n    if (qIndex !== -1) {\r\n      path = path.slice(0, Math.max(0, qIndex));\r\n    }\r\n    const matched = _router.lookup(path);\r\n    if (!matched || !matched.handlers) {\r\n      return {\r\n        error: createError({\r\n          statusCode: 404,\r\n          name: \"Not Found\",\r\n          statusMessage: `Cannot find any route matching ${path || \"/\"}.`\r\n        })\r\n      };\r\n    }\r\n    let handler = matched.handlers[method] || matched.handlers.all;\r\n    if (!handler) {\r\n      if (!_matcher) {\r\n        _matcher = toRouteMatcher(_router);\r\n      }\r\n      const _matches = _matcher.matchAll(path).reverse();\r\n      for (const _match of _matches) {\r\n        if (_match.handlers[method]) {\r\n          handler = _match.handlers[method];\r\n          matched.handlers[method] = matched.handlers[method] || handler;\r\n          break;\r\n        }\r\n        if (_match.handlers.all) {\r\n          handler = _match.handlers.all;\r\n          matched.handlers.all = matched.handlers.all || handler;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (!handler) {\r\n      return {\r\n        error: createError({\r\n          statusCode: 405,\r\n          name: \"Method Not Allowed\",\r\n          statusMessage: `Method ${method} is not allowed on this route.`\r\n        })\r\n      };\r\n    }\r\n    return { matched, handler };\r\n  };\r\n  const isPreemptive = opts.preemptive || opts.preemtive;\r\n  router.handler = eventHandler((event) => {\r\n    const match = matchHandler(\r\n      event.path,\r\n      event.method.toLowerCase()\r\n    );\r\n    if (\"error\" in match) {\r\n      if (isPreemptive) {\r\n        throw match.error;\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n    event.context.matchedRoute = match.matched;\r\n    const params = match.matched.params || {};\r\n    event.context.params = params;\r\n    return Promise.resolve(match.handler(event)).then((res) => {\r\n      if (res === void 0 && isPreemptive) {\r\n        return null;\r\n      }\r\n      return res;\r\n    });\r\n  });\r\n  router.handler.__resolve__ = async (path) => {\r\n    path = withLeadingSlash(path);\r\n    const match = matchHandler(path);\r\n    if (\"error\" in match) {\r\n      return;\r\n    }\r\n    let res = {\r\n      route: match.matched.path,\r\n      handler: match.handler\r\n    };\r\n    if (match.handler.__resolve__) {\r\n      const _res = await match.handler.__resolve__(path);\r\n      if (!_res) {\r\n        return;\r\n      }\r\n      res = { ...res, ..._res };\r\n    }\r\n    return res;\r\n  };\r\n  return router;\r\n}\r\n\r\nconst defineNodeListener = (handler) => handler;\r\nconst defineNodeMiddleware = (middleware) => middleware;\r\nfunction fromNodeMiddleware(handler) {\r\n  if (isEventHandler(handler)) {\r\n    return handler;\r\n  }\r\n  if (typeof handler !== \"function\") {\r\n    throw new TypeError(\r\n      \"Invalid handler. It should be a function:\",\r\n      handler\r\n    );\r\n  }\r\n  return eventHandler((event) => {\r\n    return callNodeListener(\r\n      handler,\r\n      event.node.req,\r\n      event.node.res\r\n    );\r\n  });\r\n}\r\nfunction toNodeListener(app) {\r\n  const toNodeHandle = async function(req, res) {\r\n    const event = createEvent(req, res);\r\n    try {\r\n      await app.handler(event);\r\n    } catch (_error) {\r\n      const error = createError(_error);\r\n      if (!isError(_error)) {\r\n        error.unhandled = true;\r\n      }\r\n      if (app.options.onError) {\r\n        await app.options.onError(error, event);\r\n      }\r\n      if (event.handled) {\r\n        return;\r\n      }\r\n      if (error.unhandled || error.fatal) {\r\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\r\n      }\r\n      await sendError(event, error, !!app.options.debug);\r\n    }\r\n  };\r\n  return toNodeHandle;\r\n}\r\nfunction promisifyNodeListener(handler) {\r\n  return function(req, res) {\r\n    return callNodeListener(handler, req, res);\r\n  };\r\n}\r\nfunction callNodeListener(handler, req, res) {\r\n  const isMiddleware = handler.length > 2;\r\n  return new Promise((resolve, reject) => {\r\n    const next = (err) => {\r\n      if (isMiddleware) {\r\n        res.off(\"close\", next);\r\n        res.off(\"error\", next);\r\n      }\r\n      return err ? reject(createError(err)) : resolve(void 0);\r\n    };\r\n    try {\r\n      const returned = handler(req, res, next);\r\n      if (isMiddleware && returned === void 0) {\r\n        res.once(\"close\", next);\r\n        res.once(\"error\", next);\r\n      } else {\r\n        resolve(returned);\r\n      }\r\n    } catch (error) {\r\n      next(error);\r\n    }\r\n  });\r\n}\r\n\r\nfunction toPlainHandler(app) {\r\n  const handler = (request) => {\r\n    return _handlePlainRequest(app, request);\r\n  };\r\n  return handler;\r\n}\r\nfunction fromPlainHandler(handler) {\r\n  return eventHandler(async (event) => {\r\n    const res = await handler({\r\n      method: event.method,\r\n      path: event.path,\r\n      headers: Object.fromEntries(event.headers.entries()),\r\n      body: getRequestWebStream(event),\r\n      context: event.context\r\n    });\r\n    setResponseStatus(event, res.status, res.statusText);\r\n    for (const [key, value] of res.headers) {\r\n      setResponseHeader(event, key, value);\r\n    }\r\n    return res.body;\r\n  });\r\n}\r\nasync function _handlePlainRequest(app, request) {\r\n  const path = request.path;\r\n  const method = (request.method || \"GET\").toUpperCase();\r\n  const headers = new Headers(request.headers);\r\n  const nodeReq = new IncomingMessage();\r\n  const nodeRes = new ServerResponse(nodeReq);\r\n  nodeReq.method = method;\r\n  nodeReq.url = path;\r\n  nodeReq.headers = Object.fromEntries(headers.entries());\r\n  const event = createEvent(nodeReq, nodeRes);\r\n  event._method = method;\r\n  event._path = path;\r\n  event._headers = headers;\r\n  if (request.body) {\r\n    event._requestBody = request.body;\r\n  }\r\n  if (request._eventOverrides) {\r\n    Object.assign(event, request._eventOverrides);\r\n  }\r\n  if (request.context) {\r\n    Object.assign(event.context, request.context);\r\n  }\r\n  try {\r\n    await app.handler(event);\r\n  } catch (_error) {\r\n    const error = createError(_error);\r\n    if (!isError(_error)) {\r\n      error.unhandled = true;\r\n    }\r\n    if (app.options.onError) {\r\n      await app.options.onError(error, event);\r\n    }\r\n    if (!event.handled) {\r\n      if (error.unhandled || error.fatal) {\r\n        console.error(\"[h3]\", error.fatal ? \"[fatal]\" : \"[unhandled]\", error);\r\n      }\r\n      await sendError(event, error, !!app.options.debug);\r\n    }\r\n  }\r\n  return {\r\n    status: nodeRes.statusCode,\r\n    statusText: nodeRes.statusMessage,\r\n    headers: _normalizeUnenvHeaders(nodeRes._headers),\r\n    body: nodeRes._data\r\n  };\r\n}\r\nfunction _normalizeUnenvHeaders(input) {\r\n  const headers = [];\r\n  const cookies = [];\r\n  for (const _key in input) {\r\n    const key = _key.toLowerCase();\r\n    if (key === \"set-cookie\") {\r\n      cookies.push(\r\n        ...splitCookiesString(input[\"set-cookie\"])\r\n      );\r\n      continue;\r\n    }\r\n    const value = input[key];\r\n    if (Array.isArray(value)) {\r\n      for (const _value of value) {\r\n        headers.push([key, _value]);\r\n      }\r\n    } else if (value !== void 0) {\r\n      headers.push([key, String(value)]);\r\n    }\r\n  }\r\n  if (cookies.length > 0) {\r\n    for (const cookie of cookies) {\r\n      headers.push([\"set-cookie\", cookie]);\r\n    }\r\n  }\r\n  return headers;\r\n}\r\n\r\nfunction toWebHandler(app) {\r\n  const webHandler = (request, context) => {\r\n    return _handleWebRequest(app, request, context);\r\n  };\r\n  return webHandler;\r\n}\r\nfunction fromWebHandler(handler) {\r\n  return eventHandler((event) => handler(toWebRequest(event), event.context));\r\n}\r\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\r\nasync function _handleWebRequest(app, request, context) {\r\n  const url = new URL(request.url);\r\n  const res = await _handlePlainRequest(app, {\r\n    _eventOverrides: {\r\n      web: { request, url }\r\n    },\r\n    context,\r\n    method: request.method,\r\n    path: url.pathname + url.search,\r\n    headers: request.headers,\r\n    body: request.body\r\n  });\r\n  const body = nullBodyResponses.has(res.status) || request.method === \"HEAD\" ? null : res.body;\r\n  return new Response(body, {\r\n    status: res.status,\r\n    statusText: res.statusText,\r\n    headers: res.headers\r\n  });\r\n}\r\n\r\nexport { H3Error, H3Event, H3Headers, H3Response, MIMES, appendCorsHeaders, appendCorsPreflightHeaders, appendHeader, appendHeaders, appendResponseHeader, appendResponseHeaders, assertMethod, callNodeListener, clearResponseHeaders, clearSession, createApp, createAppEventHandler, createError, createEvent, createEventStream, createRouter, defaultContentType, defineEventHandler, defineLazyEventHandler, defineNodeListener, defineNodeMiddleware, defineRequestMiddleware, defineResponseMiddleware, defineWebSocket, defineWebSocketHandler, deleteCookie, dynamicEventHandler, eventHandler, fetchWithEvent, fromNodeMiddleware, fromPlainHandler, fromWebHandler, getCookie, getHeader, getHeaders, getMethod, getProxyRequestHeaders, getQuery, getRequestFingerprint, getRequestHeader, getRequestHeaders, getRequestHost, getRequestIP, getRequestPath, getRequestProtocol, getRequestURL, getRequestWebStream, getResponseHeader, getResponseHeaders, getResponseStatus, getResponseStatusText, getRouterParam, getRouterParams, getSession, getValidatedQuery, getValidatedRouterParams, handleCacheHeaders, handleCors, isCorsOriginAllowed, isError, isEvent, isEventHandler, isMethod, isPreflightRequest, isStream, isWebResponse, lazyEventHandler, parseCookies, promisifyNodeListener, proxyRequest, readBody, readFormData, readMultipartFormData, readRawBody, readValidatedBody, removeResponseHeader, sanitizeStatusCode, sanitizeStatusMessage, sealSession, send, sendError, sendIterable, sendNoContent, sendProxy, sendRedirect, sendStream, sendWebResponse, serveStatic, setCookie, setHeader, setHeaders, setResponseHeader, setResponseHeaders, setResponseStatus, splitCookiesString, toEventHandler, toNodeListener, toPlainHandler, toWebHandler, toWebRequest, unsealSession, updateSession, use, useBase, useSession, writeEarlyHints };\r\n",
      "start": 1714315492680,
      "end": 1714315492831,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714315492831,
      "end": 1714315492831,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714315492831,
      "end": 1714315492832,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714315492832,
      "end": 1714315492832,
      "order": "normal"
    }
  ]
}
