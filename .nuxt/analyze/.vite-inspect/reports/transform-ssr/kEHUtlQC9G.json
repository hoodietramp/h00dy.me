{
  "resolvedId": "C:/Users/h00dy/Documents/github/h00dy.me/node_modules/pinia/dist/pinia.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "/*!\r\n * pinia v2.1.7\r\n * (c) 2023 Eduardo San Martin Morote\r\n * @license MIT\r\n */\r\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\r\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\r\n\r\n/**\r\n * setActivePinia must be called to handle SSR at the top of functions like\r\n * `fetch`, `setup`, `serverPrefetch` and others\r\n */\r\nlet activePinia;\r\n/**\r\n * Sets or unsets the active pinia. Used in SSR and internally when calling\r\n * actions and getters\r\n *\r\n * @param pinia - Pinia instance\r\n */\r\n// @ts-expect-error: cannot constrain the type of the return\r\nconst setActivePinia = (pinia) => (activePinia = pinia);\r\n/**\r\n * Get the currently active pinia if there is any.\r\n */\r\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\r\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\r\n\r\nfunction isPlainObject(\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no) {\r\n    return (o &&\r\n        typeof o === 'object' &&\r\n        Object.prototype.toString.call(o) === '[object Object]' &&\r\n        typeof o.toJSON !== 'function');\r\n}\r\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\r\n// TODO: can we change these to numbers?\r\n/**\r\n * Possible types for SubscriptionCallback\r\n */\r\nvar MutationType;\r\n(function (MutationType) {\r\n    /**\r\n     * Direct mutation of the state:\r\n     *\r\n     * - `store.name = 'new name'`\r\n     * - `store.$state.name = 'new name'`\r\n     * - `store.list.push('new item')`\r\n     */\r\n    MutationType[\"direct\"] = \"direct\";\r\n    /**\r\n     * Mutated the state with `$patch` and an object\r\n     *\r\n     * - `store.$patch({ name: 'newName' })`\r\n     */\r\n    MutationType[\"patchObject\"] = \"patch object\";\r\n    /**\r\n     * Mutated the state with `$patch` and a function\r\n     *\r\n     * - `store.$patch(state => state.name = 'newName')`\r\n     */\r\n    MutationType[\"patchFunction\"] = \"patch function\";\r\n    // maybe reset? for $state = {} and $reset\r\n})(MutationType || (MutationType = {}));\r\n\r\nconst IS_CLIENT = typeof window !== 'undefined';\r\n/**\r\n * Should we add the devtools plugins.\r\n * - only if dev mode or forced through the prod devtools flag\r\n * - not in test\r\n * - only if window exists (could change in the future)\r\n */\r\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\r\n\r\n/*\r\n * FileSaver.js A saveAs() FileSaver implementation.\r\n *\r\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\r\n * Morote.\r\n *\r\n * License : MIT\r\n */\r\n// The one and only way of getting global scope in all environments\r\n// https://stackoverflow.com/q/3277182/1008999\r\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\r\n    ? window\r\n    : typeof self === 'object' && self.self === self\r\n        ? self\r\n        : typeof global === 'object' && global.global === global\r\n            ? global\r\n            : typeof globalThis === 'object'\r\n                ? globalThis\r\n                : { HTMLElement: null })();\r\nfunction bom(blob, { autoBom = false } = {}) {\r\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\r\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\r\n    if (autoBom &&\r\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\r\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\r\n    }\r\n    return blob;\r\n}\r\nfunction download(url, name, opts) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url);\r\n    xhr.responseType = 'blob';\r\n    xhr.onload = function () {\r\n        saveAs(xhr.response, name, opts);\r\n    };\r\n    xhr.onerror = function () {\r\n        console.error('could not download file');\r\n    };\r\n    xhr.send();\r\n}\r\nfunction corsEnabled(url) {\r\n    const xhr = new XMLHttpRequest();\r\n    // use sync to avoid popup blocker\r\n    xhr.open('HEAD', url, false);\r\n    try {\r\n        xhr.send();\r\n    }\r\n    catch (e) { }\r\n    return xhr.status >= 200 && xhr.status <= 299;\r\n}\r\n// `a.click()` doesn't work for all browsers (#465)\r\nfunction click(node) {\r\n    try {\r\n        node.dispatchEvent(new MouseEvent('click'));\r\n    }\r\n    catch (e) {\r\n        const evt = document.createEvent('MouseEvents');\r\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n        node.dispatchEvent(evt);\r\n    }\r\n}\r\nconst _navigator = \r\n typeof navigator === 'object' ? navigator : { userAgent: '' };\r\n// Detect WebView inside a native macOS app by ruling out all browsers\r\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\r\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\r\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\r\n    /AppleWebKit/.test(_navigator.userAgent) &&\r\n    !/Safari/.test(_navigator.userAgent))();\r\nconst saveAs = !IS_CLIENT\r\n    ? () => { } // noop\r\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\r\n        typeof HTMLAnchorElement !== 'undefined' &&\r\n            'download' in HTMLAnchorElement.prototype &&\r\n            !isMacOSWebView\r\n            ? downloadSaveAs\r\n            : // Use msSaveOrOpenBlob as a second approach\r\n                'msSaveOrOpenBlob' in _navigator\r\n                    ? msSaveAs\r\n                    : // Fallback to using FileReader and a popup\r\n                        fileSaverSaveAs;\r\nfunction downloadSaveAs(blob, name = 'download', opts) {\r\n    const a = document.createElement('a');\r\n    a.download = name;\r\n    a.rel = 'noopener'; // tabnabbing\r\n    // TODO: detect chrome extensions & packaged apps\r\n    // a.target = '_blank'\r\n    if (typeof blob === 'string') {\r\n        // Support regular links\r\n        a.href = blob;\r\n        if (a.origin !== location.origin) {\r\n            if (corsEnabled(a.href)) {\r\n                download(blob, name, opts);\r\n            }\r\n            else {\r\n                a.target = '_blank';\r\n                click(a);\r\n            }\r\n        }\r\n        else {\r\n            click(a);\r\n        }\r\n    }\r\n    else {\r\n        // Support blobs\r\n        a.href = URL.createObjectURL(blob);\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(a.href);\r\n        }, 4e4); // 40s\r\n        setTimeout(function () {\r\n            click(a);\r\n        }, 0);\r\n    }\r\n}\r\nfunction msSaveAs(blob, name = 'download', opts) {\r\n    if (typeof blob === 'string') {\r\n        if (corsEnabled(blob)) {\r\n            download(blob, name, opts);\r\n        }\r\n        else {\r\n            const a = document.createElement('a');\r\n            a.href = blob;\r\n            a.target = '_blank';\r\n            setTimeout(function () {\r\n                click(a);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        // @ts-ignore: works on windows\r\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\r\n    }\r\n}\r\nfunction fileSaverSaveAs(blob, name, opts, popup) {\r\n    // Open a popup immediately do go around popup blocker\r\n    // Mostly only available on user interaction and the fileReader is async so...\r\n    popup = popup || open('', '_blank');\r\n    if (popup) {\r\n        popup.document.title = popup.document.body.innerText = 'downloading...';\r\n    }\r\n    if (typeof blob === 'string')\r\n        return download(blob, name, opts);\r\n    const force = blob.type === 'application/octet-stream';\r\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\r\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\r\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\r\n        typeof FileReader !== 'undefined') {\r\n        // Safari doesn't allow downloading of blob URLs\r\n        const reader = new FileReader();\r\n        reader.onloadend = function () {\r\n            let url = reader.result;\r\n            if (typeof url !== 'string') {\r\n                popup = null;\r\n                throw new Error('Wrong reader.result type');\r\n            }\r\n            url = isChromeIOS\r\n                ? url\r\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n            if (popup) {\r\n                popup.location.href = url;\r\n            }\r\n            else {\r\n                location.assign(url);\r\n            }\r\n            popup = null; // reverse-tabnabbing #460\r\n        };\r\n        reader.readAsDataURL(blob);\r\n    }\r\n    else {\r\n        const url = URL.createObjectURL(blob);\r\n        if (popup)\r\n            popup.location.assign(url);\r\n        else\r\n            location.href = url;\r\n        popup = null; // reverse-tabnabbing #460\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(url);\r\n        }, 4e4); // 40s\r\n    }\r\n}\r\n\r\n/**\r\n * Shows a toast or console.log\r\n *\r\n * @param message - message to log\r\n * @param type - different color of the tooltip\r\n */\r\nfunction toastMessage(message, type) {\r\n    const piniaMessage = '🍍 ' + message;\r\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\r\n        // No longer available :(\r\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\r\n    }\r\n    else if (type === 'error') {\r\n        console.error(piniaMessage);\r\n    }\r\n    else if (type === 'warn') {\r\n        console.warn(piniaMessage);\r\n    }\r\n    else {\r\n        console.log(piniaMessage);\r\n    }\r\n}\r\nfunction isPinia(o) {\r\n    return '_a' in o && 'install' in o;\r\n}\r\n\r\n/**\r\n * This file contain devtools actions, they are not Pinia actions.\r\n */\r\n// ---\r\nfunction checkClipboardAccess() {\r\n    if (!('clipboard' in navigator)) {\r\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\r\n        return true;\r\n    }\r\n}\r\nfunction checkNotFocusedError(error) {\r\n    if (error instanceof Error &&\r\n        error.message.toLowerCase().includes('document is not focused')) {\r\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nasync function actionGlobalCopyState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\r\n        toastMessage('Global state copied to clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalPasteState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\r\n        toastMessage('Global state pasted from clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalSaveState(pinia) {\r\n    try {\r\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\r\n            type: 'text/plain;charset=utf-8',\r\n        }), 'pinia-state.json');\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nlet fileInput;\r\nfunction getFileOpener() {\r\n    if (!fileInput) {\r\n        fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.accept = '.json';\r\n    }\r\n    function openFile() {\r\n        return new Promise((resolve, reject) => {\r\n            fileInput.onchange = async () => {\r\n                const files = fileInput.files;\r\n                if (!files)\r\n                    return resolve(null);\r\n                const file = files.item(0);\r\n                if (!file)\r\n                    return resolve(null);\r\n                return resolve({ text: await file.text(), file });\r\n            };\r\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\r\n            fileInput.oncancel = () => resolve(null);\r\n            fileInput.onerror = reject;\r\n            fileInput.click();\r\n        });\r\n    }\r\n    return openFile;\r\n}\r\nasync function actionGlobalOpenStateFile(pinia) {\r\n    try {\r\n        const open = getFileOpener();\r\n        const result = await open();\r\n        if (!result)\r\n            return;\r\n        const { text, file } = result;\r\n        loadStoresState(pinia, JSON.parse(text));\r\n        toastMessage(`Global state imported from \"${file.name}\".`);\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nfunction loadStoresState(pinia, state) {\r\n    for (const key in state) {\r\n        const storeState = pinia.state.value[key];\r\n        // store is already instantiated, patch it\r\n        if (storeState) {\r\n            Object.assign(storeState, state[key]);\r\n        }\r\n        else {\r\n            // store is not instantiated, set the initial state\r\n            pinia.state.value[key] = state[key];\r\n        }\r\n    }\r\n}\r\n\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\r\nconst PINIA_ROOT_ID = '_root';\r\nfunction formatStoreForInspectorTree(store) {\r\n    return isPinia(store)\r\n        ? {\r\n            id: PINIA_ROOT_ID,\r\n            label: PINIA_ROOT_LABEL,\r\n        }\r\n        : {\r\n            id: store.$id,\r\n            label: store.$id,\r\n        };\r\n}\r\nfunction formatStoreForInspectorState(store) {\r\n    if (isPinia(store)) {\r\n        const storeNames = Array.from(store._s.keys());\r\n        const storeMap = store._s;\r\n        const state = {\r\n            state: storeNames.map((storeId) => ({\r\n                editable: true,\r\n                key: storeId,\r\n                value: store.state.value[storeId],\r\n            })),\r\n            getters: storeNames\r\n                .filter((id) => storeMap.get(id)._getters)\r\n                .map((id) => {\r\n                const store = storeMap.get(id);\r\n                return {\r\n                    editable: false,\r\n                    key: id,\r\n                    value: store._getters.reduce((getters, key) => {\r\n                        getters[key] = store[key];\r\n                        return getters;\r\n                    }, {}),\r\n                };\r\n            }),\r\n        };\r\n        return state;\r\n    }\r\n    const state = {\r\n        state: Object.keys(store.$state).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store.$state[key],\r\n        })),\r\n    };\r\n    // avoid adding empty getters\r\n    if (store._getters && store._getters.length) {\r\n        state.getters = store._getters.map((getterName) => ({\r\n            editable: false,\r\n            key: getterName,\r\n            value: store[getterName],\r\n        }));\r\n    }\r\n    if (store._customProperties.size) {\r\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store[key],\r\n        }));\r\n    }\r\n    return state;\r\n}\r\nfunction formatEventData(events) {\r\n    if (!events)\r\n        return {};\r\n    if (Array.isArray(events)) {\r\n        // TODO: handle add and delete for arrays and objects\r\n        return events.reduce((data, event) => {\r\n            data.keys.push(event.key);\r\n            data.operations.push(event.type);\r\n            data.oldValue[event.key] = event.oldValue;\r\n            data.newValue[event.key] = event.newValue;\r\n            return data;\r\n        }, {\r\n            oldValue: {},\r\n            keys: [],\r\n            operations: [],\r\n            newValue: {},\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            operation: formatDisplay(events.type),\r\n            key: formatDisplay(events.key),\r\n            oldValue: events.oldValue,\r\n            newValue: events.newValue,\r\n        };\r\n    }\r\n}\r\nfunction formatMutationType(type) {\r\n    switch (type) {\r\n        case MutationType.direct:\r\n            return 'mutation';\r\n        case MutationType.patchFunction:\r\n            return '$patch';\r\n        case MutationType.patchObject:\r\n            return '$patch';\r\n        default:\r\n            return 'unknown';\r\n    }\r\n}\r\n\r\n// timeline can be paused when directly changing the state\r\nlet isTimelineActive = true;\r\nconst componentStateTypes = [];\r\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\r\nconst INSPECTOR_ID = 'pinia';\r\nconst { assign: assign$1 } = Object;\r\n/**\r\n * Gets the displayed name of a store in devtools\r\n *\r\n * @param id - id of the store\r\n * @returns a formatted string\r\n */\r\nconst getStoreType = (id) => '🍍 ' + id;\r\n/**\r\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\r\n * as soon as it is added to the application.\r\n *\r\n * @param app - Vue application\r\n * @param pinia - pinia instance\r\n */\r\nfunction registerPiniaDevtools(app, pinia) {\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia 🍍',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n    }, (api) => {\r\n        if (typeof api.now !== 'function') {\r\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\r\n        }\r\n        api.addTimelineLayer({\r\n            id: MUTATIONS_LAYER_ID,\r\n            label: `Pinia 🍍`,\r\n            color: 0xe5df88,\r\n        });\r\n        api.addInspector({\r\n            id: INSPECTOR_ID,\r\n            label: 'Pinia 🍍',\r\n            icon: 'storage',\r\n            treeFilterPlaceholder: 'Search stores',\r\n            actions: [\r\n                {\r\n                    icon: 'content_copy',\r\n                    action: () => {\r\n                        actionGlobalCopyState(pinia);\r\n                    },\r\n                    tooltip: 'Serialize and copy the state',\r\n                },\r\n                {\r\n                    icon: 'content_paste',\r\n                    action: async () => {\r\n                        await actionGlobalPasteState(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Replace the state with the content of your clipboard',\r\n                },\r\n                {\r\n                    icon: 'save',\r\n                    action: () => {\r\n                        actionGlobalSaveState(pinia);\r\n                    },\r\n                    tooltip: 'Save the state as a JSON file',\r\n                },\r\n                {\r\n                    icon: 'folder_open',\r\n                    action: async () => {\r\n                        await actionGlobalOpenStateFile(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Import the state from a JSON file',\r\n                },\r\n            ],\r\n            nodeActions: [\r\n                {\r\n                    icon: 'restore',\r\n                    tooltip: 'Reset the state (with \"$reset\")',\r\n                    action: (nodeId) => {\r\n                        const store = pinia._s.get(nodeId);\r\n                        if (!store) {\r\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\r\n                        }\r\n                        else if (typeof store.$reset !== 'function') {\r\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\r\n                        }\r\n                        else {\r\n                            store.$reset();\r\n                            toastMessage(`Store \"${nodeId}\" reset.`);\r\n                        }\r\n                    },\r\n                },\r\n            ],\r\n        });\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            const proxy = (payload.componentInstance &&\r\n                payload.componentInstance.proxy);\r\n            if (proxy && proxy._pStores) {\r\n                const piniaStores = payload.componentInstance.proxy._pStores;\r\n                Object.values(piniaStores).forEach((store) => {\r\n                    payload.instanceData.state.push({\r\n                        type: getStoreType(store.$id),\r\n                        key: 'state',\r\n                        editable: true,\r\n                        value: store._isOptionsAPI\r\n                            ? {\r\n                                _custom: {\r\n                                    value: toRaw(store.$state),\r\n                                    actions: [\r\n                                        {\r\n                                            icon: 'restore',\r\n                                            tooltip: 'Reset the state of this store',\r\n                                            action: () => store.$reset(),\r\n                                        },\r\n                                    ],\r\n                                },\r\n                            }\r\n                            : // NOTE: workaround to unwrap transferred refs\r\n                                Object.keys(store.$state).reduce((state, key) => {\r\n                                    state[key] = store.$state[key];\r\n                                    return state;\r\n                                }, {}),\r\n                    });\r\n                    if (store._getters && store._getters.length) {\r\n                        payload.instanceData.state.push({\r\n                            type: getStoreType(store.$id),\r\n                            key: 'getters',\r\n                            editable: false,\r\n                            value: store._getters.reduce((getters, key) => {\r\n                                try {\r\n                                    getters[key] = store[key];\r\n                                }\r\n                                catch (error) {\r\n                                    // @ts-expect-error: we just want to show it in devtools\r\n                                    getters[key] = error;\r\n                                }\r\n                                return getters;\r\n                            }, {}),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        api.on.getInspectorTree((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                let stores = [pinia];\r\n                stores = stores.concat(Array.from(pinia._s.values()));\r\n                payload.rootNodes = (payload.filter\r\n                    ? stores.filter((store) => '$id' in store\r\n                        ? store.$id\r\n                            .toLowerCase()\r\n                            .includes(payload.filter.toLowerCase())\r\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\r\n                    : stores).map(formatStoreForInspectorTree);\r\n            }\r\n        });\r\n        api.on.getInspectorState((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    // this could be the selected store restored for a different project\r\n                    // so it's better not to say anything here\r\n                    return;\r\n                }\r\n                if (inspectedStore) {\r\n                    payload.state = formatStoreForInspectorState(inspectedStore);\r\n                }\r\n            }\r\n        });\r\n        api.on.editInspectorState((payload, ctx) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (!isPinia(inspectedStore)) {\r\n                    // access only the state\r\n                    if (path.length !== 1 ||\r\n                        !inspectedStore._customProperties.has(path[0]) ||\r\n                        path[0] in inspectedStore.$state) {\r\n                        path.unshift('$state');\r\n                    }\r\n                }\r\n                else {\r\n                    // Root access, we can omit the `.value` because the devtools API does it for us\r\n                    path.unshift('state');\r\n                }\r\n                isTimelineActive = false;\r\n                payload.set(inspectedStore, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n        api.on.editComponentState((payload) => {\r\n            if (payload.type.startsWith('🍍')) {\r\n                const storeId = payload.type.replace(/^🍍\\s*/, '');\r\n                const store = pinia._s.get(storeId);\r\n                if (!store) {\r\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (path[0] !== 'state') {\r\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\r\n                }\r\n                // rewrite the first entry to be able to directly set the state as\r\n                // well as any other path\r\n                path[0] = '$state';\r\n                isTimelineActive = false;\r\n                payload.set(store, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addStoreToDevtools(app, store) {\r\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\r\n        componentStateTypes.push(getStoreType(store.$id));\r\n    }\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia 🍍',\r\n        logo: 'https://pinia.vuejs.org/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.vuejs.org',\r\n        componentStateTypes,\r\n        app,\r\n        settings: {\r\n            logStoreChanges: {\r\n                label: 'Notify about new/deleted stores',\r\n                type: 'boolean',\r\n                defaultValue: true,\r\n            },\r\n            // useEmojis: {\r\n            //   label: 'Use emojis in messages ⚡️',\r\n            //   type: 'boolean',\r\n            //   defaultValue: true,\r\n            // },\r\n        },\r\n    }, (api) => {\r\n        // gracefully handle errors\r\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\r\n        store.$onAction(({ after, onError, name, args }) => {\r\n            const groupId = runningActionId++;\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: '🛫 ' + name,\r\n                    subtitle: 'start',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        action: formatDisplay(name),\r\n                        args,\r\n                    },\r\n                    groupId,\r\n                },\r\n            });\r\n            after((result) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        title: '🛬 ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            result,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n            onError((error) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: now(),\r\n                        logType: 'error',\r\n                        title: '💥 ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            error,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n        }, true);\r\n        store._customProperties.forEach((name) => {\r\n            watch(() => unref(store[name]), (newValue, oldValue) => {\r\n                api.notifyComponentUpdate();\r\n                api.sendInspectorState(INSPECTOR_ID);\r\n                if (isTimelineActive) {\r\n                    api.addTimelineEvent({\r\n                        layerId: MUTATIONS_LAYER_ID,\r\n                        event: {\r\n                            time: now(),\r\n                            title: 'Change',\r\n                            subtitle: name,\r\n                            data: {\r\n                                newValue,\r\n                                oldValue,\r\n                            },\r\n                            groupId: activeAction,\r\n                        },\r\n                    });\r\n                }\r\n            }, { deep: true });\r\n        });\r\n        store.$subscribe(({ events, type }, state) => {\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            if (!isTimelineActive)\r\n                return;\r\n            // rootStore.state[store.id] = state\r\n            const eventData = {\r\n                time: now(),\r\n                title: formatMutationType(type),\r\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\r\n                groupId: activeAction,\r\n            };\r\n            if (type === MutationType.patchFunction) {\r\n                eventData.subtitle = '⤵️';\r\n            }\r\n            else if (type === MutationType.patchObject) {\r\n                eventData.subtitle = '🧩';\r\n            }\r\n            else if (events && !Array.isArray(events)) {\r\n                eventData.subtitle = events.type;\r\n            }\r\n            if (events) {\r\n                eventData.data['rawEvent(s)'] = {\r\n                    _custom: {\r\n                        display: 'DebuggerEvent',\r\n                        type: 'object',\r\n                        tooltip: 'raw DebuggerEvent[]',\r\n                        value: events,\r\n                    },\r\n                };\r\n            }\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: eventData,\r\n            });\r\n        }, { detached: true, flush: 'sync' });\r\n        const hotUpdate = store._hotUpdate;\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            hotUpdate(newStore);\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: now(),\r\n                    title: '🔥 ' + store.$id,\r\n                    subtitle: 'HMR update',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        info: formatDisplay(`HMR update`),\r\n                    },\r\n                },\r\n            });\r\n            // update the devtools too\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n        });\r\n        const { $dispose } = store;\r\n        store.$dispose = () => {\r\n            $dispose();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            api.getSettings().logStoreChanges &&\r\n                toastMessage(`Disposed \"${store.$id}\" store 🗑`);\r\n        };\r\n        // trigger an update so it can display new registered stores\r\n        api.notifyComponentUpdate();\r\n        api.sendInspectorTree(INSPECTOR_ID);\r\n        api.sendInspectorState(INSPECTOR_ID);\r\n        api.getSettings().logStoreChanges &&\r\n            toastMessage(`\"${store.$id}\" store installed 🆕`);\r\n    });\r\n}\r\nlet runningActionId = 0;\r\nlet activeAction;\r\n/**\r\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\r\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\r\n * mutation to the action.\r\n *\r\n * @param store - store to patch\r\n * @param actionNames - list of actionst to patch\r\n */\r\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\r\n    // original actions of the store as they are given by pinia. We are going to override them\r\n    const actions = actionNames.reduce((storeActions, actionName) => {\r\n        // use toRaw to avoid tracking #541\r\n        storeActions[actionName] = toRaw(store)[actionName];\r\n        return storeActions;\r\n    }, {});\r\n    for (const actionName in actions) {\r\n        store[actionName] = function () {\r\n            // the running action id is incremented in a before action hook\r\n            const _actionId = runningActionId;\r\n            const trackedStore = wrapWithProxy\r\n                ? new Proxy(store, {\r\n                    get(...args) {\r\n                        activeAction = _actionId;\r\n                        return Reflect.get(...args);\r\n                    },\r\n                    set(...args) {\r\n                        activeAction = _actionId;\r\n                        return Reflect.set(...args);\r\n                    },\r\n                })\r\n                : store;\r\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\r\n            activeAction = _actionId;\r\n            const retValue = actions[actionName].apply(trackedStore, arguments);\r\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\r\n            activeAction = undefined;\r\n            return retValue;\r\n        };\r\n    }\r\n}\r\n/**\r\n * pinia.use(devtoolsPlugin)\r\n */\r\nfunction devtoolsPlugin({ app, store, options }) {\r\n    // HMR module\r\n    if (store.$id.startsWith('__hot:')) {\r\n        return;\r\n    }\r\n    // detect option api vs setup api\r\n    store._isOptionsAPI = !!options.state;\r\n    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\r\n    // Upgrade the HMR to also update the new actions\r\n    const originalHotUpdate = store._hotUpdate;\r\n    toRaw(store)._hotUpdate = function (newStore) {\r\n        originalHotUpdate.apply(this, arguments);\r\n        patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\r\n    };\r\n    addStoreToDevtools(app, \r\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\r\n    store);\r\n}\r\n\r\n/**\r\n * Creates a Pinia instance to be used by the application\r\n */\r\nfunction createPinia() {\r\n    const scope = effectScope(true);\r\n    // NOTE: here we could check the window object for a state and directly set it\r\n    // if there is anything like it with Vue 3 SSR\r\n    const state = scope.run(() => ref({}));\r\n    let _p = [];\r\n    // plugins added before calling app.use(pinia)\r\n    let toBeInstalled = [];\r\n    const pinia = markRaw({\r\n        install(app) {\r\n            // this allows calling useStore() outside of a component setup after\r\n            // installing pinia's plugin\r\n            setActivePinia(pinia);\r\n            if (!isVue2) {\r\n                pinia._a = app;\r\n                app.provide(piniaSymbol, pinia);\r\n                app.config.globalProperties.$pinia = pinia;\r\n                /* istanbul ignore else */\r\n                if (USE_DEVTOOLS) {\r\n                    registerPiniaDevtools(app, pinia);\r\n                }\r\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\r\n                toBeInstalled = [];\r\n            }\r\n        },\r\n        use(plugin) {\r\n            if (!this._a && !isVue2) {\r\n                toBeInstalled.push(plugin);\r\n            }\r\n            else {\r\n                _p.push(plugin);\r\n            }\r\n            return this;\r\n        },\r\n        _p,\r\n        // it's actually undefined here\r\n        // @ts-expect-error\r\n        _a: null,\r\n        _e: scope,\r\n        _s: new Map(),\r\n        state,\r\n    });\r\n    // pinia devtools rely on dev only features so they cannot be forced unless\r\n    // the dev build of Vue is used. Avoid old browsers like IE11.\r\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\r\n        pinia.use(devtoolsPlugin);\r\n    }\r\n    return pinia;\r\n}\r\n\r\n/**\r\n * Checks if a function is a `StoreDefinition`.\r\n *\r\n * @param fn - object to test\r\n * @returns true if `fn` is a StoreDefinition\r\n */\r\nconst isUseStore = (fn) => {\r\n    return typeof fn === 'function' && typeof fn.$id === 'string';\r\n};\r\n/**\r\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\r\n * remove any key not existing in `newState` and recursively merge plain\r\n * objects.\r\n *\r\n * @param newState - new state object to be patched\r\n * @param oldState - old state that should be used to patch newState\r\n * @returns - newState\r\n */\r\nfunction patchObject(newState, oldState) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in oldState) {\r\n        const subPatch = oldState[key];\r\n        // skip the whole sub tree\r\n        if (!(key in newState)) {\r\n            continue;\r\n        }\r\n        const targetValue = newState[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            newState[key] = patchObject(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\r\n            // just set the whole thing\r\n            if (isVue2) {\r\n                set(newState, key, subPatch);\r\n            }\r\n            else {\r\n                newState[key] = subPatch;\r\n            }\r\n        }\r\n    }\r\n    return newState;\r\n}\r\n/**\r\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\r\n *\r\n * @example\r\n * ```js\r\n * const useUser = defineStore(...)\r\n * if (import.meta.hot) {\r\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\r\n * }\r\n * ```\r\n *\r\n * @param initialUseStore - return of the defineStore to hot update\r\n * @param hot - `import.meta.hot`\r\n */\r\nfunction acceptHMRUpdate(initialUseStore, hot) {\r\n    // strip as much as possible from iife.prod\r\n    if (!(process.env.NODE_ENV !== 'production')) {\r\n        return () => { };\r\n    }\r\n    return (newModule) => {\r\n        const pinia = hot.data.pinia || initialUseStore._pinia;\r\n        if (!pinia) {\r\n            // this store is still not used\r\n            return;\r\n        }\r\n        // preserve the pinia instance across loads\r\n        hot.data.pinia = pinia;\r\n        // console.log('got data', newStore)\r\n        for (const exportName in newModule) {\r\n            const useStore = newModule[exportName];\r\n            // console.log('checking for', exportName)\r\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\r\n                // console.log('Accepting update for', useStore.$id)\r\n                const id = useStore.$id;\r\n                if (id !== initialUseStore.$id) {\r\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\r\n                    // return import.meta.hot.invalidate()\r\n                    return hot.invalidate();\r\n                }\r\n                const existingStore = pinia._s.get(id);\r\n                if (!existingStore) {\r\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\r\n                    return;\r\n                }\r\n                useStore(pinia, existingStore);\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nconst noop = () => { };\r\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\r\n    subscriptions.push(callback);\r\n    const removeSubscription = () => {\r\n        const idx = subscriptions.indexOf(callback);\r\n        if (idx > -1) {\r\n            subscriptions.splice(idx, 1);\r\n            onCleanup();\r\n        }\r\n    };\r\n    if (!detached && getCurrentScope()) {\r\n        onScopeDispose(removeSubscription);\r\n    }\r\n    return removeSubscription;\r\n}\r\nfunction triggerSubscriptions(subscriptions, ...args) {\r\n    subscriptions.slice().forEach((callback) => {\r\n        callback(...args);\r\n    });\r\n}\r\n\r\nconst fallbackRunWithContext = (fn) => fn();\r\nfunction mergeReactiveObjects(target, patchToApply) {\r\n    // Handle Map instances\r\n    if (target instanceof Map && patchToApply instanceof Map) {\r\n        patchToApply.forEach((value, key) => target.set(key, value));\r\n    }\r\n    // Handle Set instances\r\n    if (target instanceof Set && patchToApply instanceof Set) {\r\n        patchToApply.forEach(target.add, target);\r\n    }\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in patchToApply) {\r\n        if (!patchToApply.hasOwnProperty(key))\r\n            continue;\r\n        const subPatch = patchToApply[key];\r\n        const targetValue = target[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            target.hasOwnProperty(key) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\r\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\r\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\r\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // @ts-expect-error: subPatch is a valid value\r\n            target[key] = subPatch;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\r\n    ? Symbol('pinia:skipHydration')\r\n    : /* istanbul ignore next */ Symbol();\r\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\r\n/**\r\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\r\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\r\n *\r\n * @param obj - target object\r\n * @returns obj\r\n */\r\nfunction skipHydrate(obj) {\r\n    return isVue2\r\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\r\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\r\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\r\n}\r\n/**\r\n * Returns whether a value should be hydrated\r\n *\r\n * @param obj - target variable\r\n * @returns true if `obj` should be hydrated\r\n */\r\nfunction shouldHydrate(obj) {\r\n    return isVue2\r\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\r\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\r\n}\r\nconst { assign } = Object;\r\nfunction isComputed(o) {\r\n    return !!(isRef(o) && o.effect);\r\n}\r\nfunction createOptionsStore(id, options, pinia, hot) {\r\n    const { state, actions, getters } = options;\r\n    const initialState = pinia.state.value[id];\r\n    let store;\r\n    function setup() {\r\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(pinia.state.value, id, state ? state() : {});\r\n            }\r\n            else {\r\n                pinia.state.value[id] = state ? state() : {};\r\n            }\r\n        }\r\n        // avoid creating a state in pinia.state.value\r\n        const localState = (process.env.NODE_ENV !== 'production') && hot\r\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\r\n                toRefs(ref(state ? state() : {}).value)\r\n            : toRefs(pinia.state.value[id]);\r\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\r\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\r\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\r\n            }\r\n            computedGetters[name] = markRaw(computed(() => {\r\n                setActivePinia(pinia);\r\n                // it was created just before\r\n                const store = pinia._s.get(id);\r\n                // allow cross using stores\r\n                /* istanbul ignore next */\r\n                if (isVue2 && !store._r)\r\n                    return;\r\n                // @ts-expect-error\r\n                // return getters![name].call(context, context)\r\n                // TODO: avoid reading the getter while assigning with a global variable\r\n                return getters[name].call(store, store);\r\n            }));\r\n            return computedGetters;\r\n        }, {}));\r\n    }\r\n    store = createSetupStore(id, setup, options, pinia, hot, true);\r\n    return store;\r\n}\r\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\r\n    let scope;\r\n    const optionsForPlugin = assign({ actions: {} }, options);\r\n    /* istanbul ignore if */\r\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\r\n        throw new Error('Pinia destroyed');\r\n    }\r\n    // watcher options for $subscribe\r\n    const $subscribeOptions = {\r\n        deep: true,\r\n        // flush: 'post',\r\n    };\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\r\n        $subscribeOptions.onTrigger = (event) => {\r\n            /* istanbul ignore else */\r\n            if (isListening) {\r\n                debuggerEvents = event;\r\n                // avoid triggering this while the store is being built and the state is being set in pinia\r\n            }\r\n            else if (isListening == false && !store._hotUpdating) {\r\n                // let patch send all the events together later\r\n                /* istanbul ignore else */\r\n                if (Array.isArray(debuggerEvents)) {\r\n                    debuggerEvents.push(event);\r\n                }\r\n                else {\r\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    // internal state\r\n    let isListening; // set to true at the end\r\n    let isSyncListening; // set to true at the end\r\n    let subscriptions = [];\r\n    let actionSubscriptions = [];\r\n    let debuggerEvents;\r\n    const initialState = pinia.state.value[$id];\r\n    // avoid setting the state for option stores if it is set\r\n    // by the setup\r\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n        /* istanbul ignore if */\r\n        if (isVue2) {\r\n            set(pinia.state.value, $id, {});\r\n        }\r\n        else {\r\n            pinia.state.value[$id] = {};\r\n        }\r\n    }\r\n    const hotState = ref({});\r\n    // avoid triggering too many listeners\r\n    // https://github.com/vuejs/pinia/issues/1129\r\n    let activeListener;\r\n    function $patch(partialStateOrMutator) {\r\n        let subscriptionMutation;\r\n        isListening = isSyncListening = false;\r\n        // reset the debugger events since patches are sync\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            debuggerEvents = [];\r\n        }\r\n        if (typeof partialStateOrMutator === 'function') {\r\n            partialStateOrMutator(pinia.state.value[$id]);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchFunction,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        else {\r\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchObject,\r\n                payload: partialStateOrMutator,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        const myListenerId = (activeListener = Symbol());\r\n        nextTick().then(() => {\r\n            if (activeListener === myListenerId) {\r\n                isListening = true;\r\n            }\r\n        });\r\n        isSyncListening = true;\r\n        // because we paused the watcher, we need to manually call the subscriptions\r\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\r\n    }\r\n    const $reset = isOptionsStore\r\n        ? function $reset() {\r\n            const { state } = options;\r\n            const newState = state ? state() : {};\r\n            // we use a patch to group all changes into one single subscription\r\n            this.$patch(($state) => {\r\n                assign($state, newState);\r\n            });\r\n        }\r\n        : /* istanbul ignore next */\r\n            (process.env.NODE_ENV !== 'production')\r\n                ? () => {\r\n                    throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\r\n                }\r\n                : noop;\r\n    function $dispose() {\r\n        scope.stop();\r\n        subscriptions = [];\r\n        actionSubscriptions = [];\r\n        pinia._s.delete($id);\r\n    }\r\n    /**\r\n     * Wraps an action to handle subscriptions.\r\n     *\r\n     * @param name - name of the action\r\n     * @param action - action to wrap\r\n     * @returns a wrapped action to handle subscriptions\r\n     */\r\n    function wrapAction(name, action) {\r\n        return function () {\r\n            setActivePinia(pinia);\r\n            const args = Array.from(arguments);\r\n            const afterCallbackList = [];\r\n            const onErrorCallbackList = [];\r\n            function after(callback) {\r\n                afterCallbackList.push(callback);\r\n            }\r\n            function onError(callback) {\r\n                onErrorCallbackList.push(callback);\r\n            }\r\n            // @ts-expect-error\r\n            triggerSubscriptions(actionSubscriptions, {\r\n                args,\r\n                name,\r\n                store,\r\n                after,\r\n                onError,\r\n            });\r\n            let ret;\r\n            try {\r\n                ret = action.apply(this && this.$id === $id ? this : store, args);\r\n                // handle sync errors\r\n            }\r\n            catch (error) {\r\n                triggerSubscriptions(onErrorCallbackList, error);\r\n                throw error;\r\n            }\r\n            if (ret instanceof Promise) {\r\n                return ret\r\n                    .then((value) => {\r\n                    triggerSubscriptions(afterCallbackList, value);\r\n                    return value;\r\n                })\r\n                    .catch((error) => {\r\n                    triggerSubscriptions(onErrorCallbackList, error);\r\n                    return Promise.reject(error);\r\n                });\r\n            }\r\n            // trigger after callbacks\r\n            triggerSubscriptions(afterCallbackList, ret);\r\n            return ret;\r\n        };\r\n    }\r\n    const _hmrPayload = /*#__PURE__*/ markRaw({\r\n        actions: {},\r\n        getters: {},\r\n        state: [],\r\n        hotState,\r\n    });\r\n    const partialStore = {\r\n        _p: pinia,\r\n        // _s: scope,\r\n        $id,\r\n        $onAction: addSubscription.bind(null, actionSubscriptions),\r\n        $patch,\r\n        $reset,\r\n        $subscribe(callback, options = {}) {\r\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\r\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\r\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\r\n                    callback({\r\n                        storeId: $id,\r\n                        type: MutationType.direct,\r\n                        events: debuggerEvents,\r\n                    }, state);\r\n                }\r\n            }, assign({}, $subscribeOptions, options)));\r\n            return removeSubscription;\r\n        },\r\n        $dispose,\r\n    };\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // start as non ready\r\n        partialStore._r = false;\r\n    }\r\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\r\n        ? assign({\r\n            _hmrPayload,\r\n            _customProperties: markRaw(new Set()), // devtools custom properties\r\n        }, partialStore\r\n        // must be added later\r\n        // setupStore\r\n        )\r\n        : partialStore);\r\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\r\n    // creating infinite loops.\r\n    pinia._s.set($id, store);\r\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\r\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\r\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));\r\n    // overwrite existing actions to support $onAction\r\n    for (const key in setupStore) {\r\n        const prop = setupStore[key];\r\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\r\n            // mark it as a piece of state to be serialized\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                set(hotState.value, key, toRef(setupStore, key));\r\n                // createOptionStore directly sets the state in pinia.state.value so we\r\n                // can just skip that\r\n            }\r\n            else if (!isOptionsStore) {\r\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\r\n                if (initialState && shouldHydrate(prop)) {\r\n                    if (isRef(prop)) {\r\n                        prop.value = initialState[key];\r\n                    }\r\n                    else {\r\n                        // probably a reactive object, lets recursively assign\r\n                        // @ts-expect-error: prop is unknown\r\n                        mergeReactiveObjects(prop, initialState[key]);\r\n                    }\r\n                }\r\n                // transfer the ref to the pinia state to keep everything in sync\r\n                /* istanbul ignore if */\r\n                if (isVue2) {\r\n                    set(pinia.state.value[$id], key, prop);\r\n                }\r\n                else {\r\n                    pinia.state.value[$id][key] = prop;\r\n                }\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.state.push(key);\r\n            }\r\n            // action\r\n        }\r\n        else if (typeof prop === 'function') {\r\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\r\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\r\n            // this a hot module replacement store because the hotUpdate method needs\r\n            // to do it with the right context\r\n            /* istanbul ignore if */\r\n            if (isVue2) {\r\n                set(setupStore, key, actionValue);\r\n            }\r\n            else {\r\n                // @ts-expect-error\r\n                setupStore[key] = actionValue;\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.actions[key] = prop;\r\n            }\r\n            // list actions so they can be used in plugins\r\n            // @ts-expect-error\r\n            optionsForPlugin.actions[key] = prop;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            // add getters for devtools\r\n            if (isComputed(prop)) {\r\n                _hmrPayload.getters[key] = isOptionsStore\r\n                    ? // @ts-expect-error\r\n                        options.getters[key]\r\n                    : prop;\r\n                if (IS_CLIENT) {\r\n                    const getters = setupStore._getters ||\r\n                        // @ts-expect-error: same\r\n                        (setupStore._getters = markRaw([]));\r\n                    getters.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // add the state, getters, and action properties\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        Object.keys(setupStore).forEach((key) => {\r\n            set(store, key, setupStore[key]);\r\n        });\r\n    }\r\n    else {\r\n        assign(store, setupStore);\r\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\r\n        // Make `storeToRefs()` work with `reactive()` #799\r\n        assign(toRaw(store), setupStore);\r\n    }\r\n    // use this instead of a computed with setter to be able to create it anywhere\r\n    // without linking the computed lifespan to wherever the store is first\r\n    // created.\r\n    Object.defineProperty(store, '$state', {\r\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\r\n        set: (state) => {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                throw new Error('cannot set hotState');\r\n            }\r\n            $patch(($state) => {\r\n                assign($state, state);\r\n            });\r\n        },\r\n    });\r\n    // add the hotUpdate before plugins to allow them to override it\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            store._hotUpdating = true;\r\n            newStore._hmrPayload.state.forEach((stateKey) => {\r\n                if (stateKey in store.$state) {\r\n                    const newStateTarget = newStore.$state[stateKey];\r\n                    const oldStateSource = store.$state[stateKey];\r\n                    if (typeof newStateTarget === 'object' &&\r\n                        isPlainObject(newStateTarget) &&\r\n                        isPlainObject(oldStateSource)) {\r\n                        patchObject(newStateTarget, oldStateSource);\r\n                    }\r\n                    else {\r\n                        // transfer the ref\r\n                        newStore.$state[stateKey] = oldStateSource;\r\n                    }\r\n                }\r\n                // patch direct access properties to allow store.stateProperty to work as\r\n                // store.$state.stateProperty\r\n                set(store, stateKey, toRef(newStore.$state, stateKey));\r\n            });\r\n            // remove deleted state properties\r\n            Object.keys(store.$state).forEach((stateKey) => {\r\n                if (!(stateKey in newStore.$state)) {\r\n                    del(store, stateKey);\r\n                }\r\n            });\r\n            // avoid devtools logging this as a mutation\r\n            isListening = false;\r\n            isSyncListening = false;\r\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\r\n            isSyncListening = true;\r\n            nextTick().then(() => {\r\n                isListening = true;\r\n            });\r\n            for (const actionName in newStore._hmrPayload.actions) {\r\n                const action = newStore[actionName];\r\n                set(store, actionName, wrapAction(actionName, action));\r\n            }\r\n            // TODO: does this work in both setup and option store?\r\n            for (const getterName in newStore._hmrPayload.getters) {\r\n                const getter = newStore._hmrPayload.getters[getterName];\r\n                const getterValue = isOptionsStore\r\n                    ? // special handling of options api\r\n                        computed(() => {\r\n                            setActivePinia(pinia);\r\n                            return getter.call(store, store);\r\n                        })\r\n                    : getter;\r\n                set(store, getterName, getterValue);\r\n            }\r\n            // remove deleted getters\r\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.getters)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // remove old actions\r\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.actions)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // update the values used in devtools and to allow deleting new properties later on\r\n            store._hmrPayload = newStore._hmrPayload;\r\n            store._getters = newStore._getters;\r\n            store._hotUpdating = false;\r\n        });\r\n    }\r\n    if (USE_DEVTOOLS) {\r\n        const nonEnumerable = {\r\n            writable: true,\r\n            configurable: true,\r\n            // avoid warning on devtools trying to display this property\r\n            enumerable: false,\r\n        };\r\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\r\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\r\n        });\r\n    }\r\n    /* istanbul ignore if */\r\n    if (isVue2) {\r\n        // mark the store as ready before plugins\r\n        store._r = true;\r\n    }\r\n    // apply all plugins\r\n    pinia._p.forEach((extender) => {\r\n        /* istanbul ignore else */\r\n        if (USE_DEVTOOLS) {\r\n            const extensions = scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            }));\r\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\r\n            assign(store, extensions);\r\n        }\r\n        else {\r\n            assign(store, scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                options: optionsForPlugin,\r\n            })));\r\n        }\r\n    });\r\n    if ((process.env.NODE_ENV !== 'production') &&\r\n        store.$state &&\r\n        typeof store.$state === 'object' &&\r\n        typeof store.$state.constructor === 'function' &&\r\n        !store.$state.constructor.toString().includes('[native code]')) {\r\n        console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\r\n            `\\tstate: () => new MyClass()\\n` +\r\n            `Found in store \"${store.$id}\".`);\r\n    }\r\n    // only apply hydrate to option stores with an initial state in pinia\r\n    if (initialState &&\r\n        isOptionsStore &&\r\n        options.hydrate) {\r\n        options.hydrate(store.$state, initialState);\r\n    }\r\n    isListening = true;\r\n    isSyncListening = true;\r\n    return store;\r\n}\r\nfunction defineStore(\r\n// TODO: add proper types from above\r\nidOrOptions, setup, setupOptions) {\r\n    let id;\r\n    let options;\r\n    const isSetupStore = typeof setup === 'function';\r\n    if (typeof idOrOptions === 'string') {\r\n        id = idOrOptions;\r\n        // the option store setup will contain the actual options in this case\r\n        options = isSetupStore ? setupOptions : setup;\r\n    }\r\n    else {\r\n        options = idOrOptions;\r\n        id = idOrOptions.id;\r\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\r\n            throw new Error(`[🍍]: \"defineStore()\" must be passed a store id as its first argument.`);\r\n        }\r\n    }\r\n    function useStore(pinia, hot) {\r\n        const hasContext = hasInjectionContext();\r\n        pinia =\r\n            // in test mode, ignore the argument provided as we can always retrieve a\r\n            // pinia instance with getActivePinia()\r\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\r\n                (hasContext ? inject(piniaSymbol, null) : null);\r\n        if (pinia)\r\n            setActivePinia(pinia);\r\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\r\n            throw new Error(`[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\r\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\r\n                `This will fail in production.`);\r\n        }\r\n        pinia = activePinia;\r\n        if (!pinia._s.has(id)) {\r\n            // creating the store registers it in `pinia._s`\r\n            if (isSetupStore) {\r\n                createSetupStore(id, setup, options, pinia);\r\n            }\r\n            else {\r\n                createOptionsStore(id, options, pinia);\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                // @ts-expect-error: not the right inferred type\r\n                useStore._pinia = pinia;\r\n            }\r\n        }\r\n        const store = pinia._s.get(id);\r\n        if ((process.env.NODE_ENV !== 'production') && hot) {\r\n            const hotId = '__hot:' + id;\r\n            const newStore = isSetupStore\r\n                ? createSetupStore(hotId, setup, options, pinia, true)\r\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\r\n            hot._hotUpdate(newStore);\r\n            // cleanup the state properties and the store from the cache\r\n            delete pinia.state.value[hotId];\r\n            pinia._s.delete(hotId);\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n            const currentInstance = getCurrentInstance();\r\n            // save stores in instances to access them devtools\r\n            if (currentInstance &&\r\n                currentInstance.proxy &&\r\n                // avoid adding stores that are just built for hot module replacement\r\n                !hot) {\r\n                const vm = currentInstance.proxy;\r\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\r\n                cache[id] = store;\r\n            }\r\n        }\r\n        // StoreGeneric cannot be casted towards Store\r\n        return store;\r\n    }\r\n    useStore.$id = id;\r\n    return useStore;\r\n}\r\n\r\nlet mapStoreSuffix = 'Store';\r\n/**\r\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\r\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\r\n * interface if you are using TypeScript.\r\n *\r\n * @param suffix - new suffix\r\n */\r\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\r\n) {\r\n    mapStoreSuffix = suffix;\r\n}\r\n/**\r\n * Allows using stores without the composition API (`setup()`) by generating an\r\n * object to be spread in the `computed` field of a component. It accepts a list\r\n * of store definitions.\r\n *\r\n * @example\r\n * ```js\r\n * export default {\r\n *   computed: {\r\n *     // other computed properties\r\n *     ...mapStores(useUserStore, useCartStore)\r\n *   },\r\n *\r\n *   created() {\r\n *     this.userStore // store with id \"user\"\r\n *     this.cartStore // store with id \"cart\"\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @param stores - list of stores to map to an object\r\n */\r\nfunction mapStores(...stores) {\r\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\r\n        console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\r\n            `Replace\\n` +\r\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\r\n            `with\\n` +\r\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\r\n            `This will fail in production if not fixed.`);\r\n        stores = stores[0];\r\n    }\r\n    return stores.reduce((reduced, useStore) => {\r\n        // @ts-expect-error: $id is added by defineStore\r\n        reduced[useStore.$id + mapStoreSuffix] = function () {\r\n            return useStore(this.$pinia);\r\n        };\r\n        return reduced;\r\n    }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            reduced[key] = function () {\r\n                return useStore(this.$pinia)[key];\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function () {\r\n                const store = useStore(this.$pinia);\r\n                const storeKey = keysOrMapper[key];\r\n                // for some reason TS is unable to infer the type of storeKey to be a\r\n                // function\r\n                return typeof storeKey === 'function'\r\n                    ? storeKey.call(this, store)\r\n                    : store[storeKey];\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Alias for `mapState()`. You should use `mapState()` instead.\r\n * @deprecated use `mapState()` instead.\r\n */\r\nconst mapGetters = mapState;\r\n/**\r\n * Allows directly using actions from your store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `methods` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapActions(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[key](...args);\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapWritableState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[key];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[key] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[keysOrMapper[key]];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n\r\n/**\r\n * Creates an object of references with all the state, getters, and plugin-added\r\n * state properties of the store. Similar to `toRefs()` but specifically\r\n * designed for Pinia stores so methods and non reactive properties are\r\n * completely ignored.\r\n *\r\n * @param store - store to extract the refs from\r\n */\r\nfunction storeToRefs(store) {\r\n    // See https://github.com/vuejs/pinia/issues/852\r\n    // It's easier to just use toRefs() even if it includes more stuff\r\n    if (isVue2) {\r\n        // @ts-expect-error: toRefs include methods and others\r\n        return toRefs(store);\r\n    }\r\n    else {\r\n        store = toRaw(store);\r\n        const refs = {};\r\n        for (const key in store) {\r\n            const value = store[key];\r\n            if (isRef(value) || isReactive(value)) {\r\n                // @ts-expect-error: the key is state or getter\r\n                refs[key] =\r\n                    // ---\r\n                    toRef(store, key);\r\n            }\r\n        }\r\n        return refs;\r\n    }\r\n}\r\n\r\n/**\r\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\r\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\r\n * https://pinia.vuejs.org/ssr/nuxt.html.\r\n *\r\n * @example\r\n * ```js\r\n * import Vue from 'vue'\r\n * import { PiniaVuePlugin, createPinia } from 'pinia'\r\n *\r\n * Vue.use(PiniaVuePlugin)\r\n * const pinia = createPinia()\r\n *\r\n * new Vue({\r\n *   el: '#app',\r\n *   // ...\r\n *   pinia,\r\n * })\r\n * ```\r\n *\r\n * @param _Vue - `Vue` imported from 'vue'.\r\n */\r\nconst PiniaVuePlugin = function (_Vue) {\r\n    // Equivalent of\r\n    // app.config.globalProperties.$pinia = pinia\r\n    _Vue.mixin({\r\n        beforeCreate() {\r\n            const options = this.$options;\r\n            if (options.pinia) {\r\n                const pinia = options.pinia;\r\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\r\n                /* istanbul ignore else */\r\n                if (!this._provided) {\r\n                    const provideCache = {};\r\n                    Object.defineProperty(this, '_provided', {\r\n                        get: () => provideCache,\r\n                        set: (v) => Object.assign(provideCache, v),\r\n                    });\r\n                }\r\n                this._provided[piniaSymbol] = pinia;\r\n                // propagate the pinia instance in an SSR friendly way\r\n                // avoid adding it to nuxt twice\r\n                /* istanbul ignore else */\r\n                if (!this.$pinia) {\r\n                    this.$pinia = pinia;\r\n                }\r\n                pinia._a = this;\r\n                if (IS_CLIENT) {\r\n                    // this allows calling useStore() outside of a component setup after\r\n                    // installing pinia's plugin\r\n                    setActivePinia(pinia);\r\n                }\r\n                if (USE_DEVTOOLS) {\r\n                    registerPiniaDevtools(pinia._a, pinia);\r\n                }\r\n            }\r\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\r\n                this.$pinia = options.parent.$pinia;\r\n            }\r\n        },\r\n        destroyed() {\r\n            delete this._pStores;\r\n        },\r\n    });\r\n};\r\n\r\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\r\n",
      "start": 1714315495355,
      "end": 1714315495383,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "server-only-component-transform",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1714315495383,
      "end": 1714315495383,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1714315495383,
      "end": 1714315495387,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "/*!\n * pinia v2.1.7\n * (c) 2023 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from \"vue-demi\";\nimport { setupDevtoolsPlugin } from \"@vue/devtools-api\";\nlet activePinia;\nconst setActivePinia = (pinia) => activePinia = pinia;\nconst getActivePinia = () => hasInjectionContext() && inject(piniaSymbol) || activePinia;\nconst piniaSymbol = process.env.NODE_ENV !== \"production\" ? Symbol(\"pinia\") : (\n  /* istanbul ignore next */\n  Symbol()\n);\nfunction isPlainObject(o) {\n  return o && typeof o === \"object\" && Object.prototype.toString.call(o) === \"[object Object]\" && typeof o.toJSON !== \"function\";\n}\nvar MutationType;\n(function(MutationType2) {\n  MutationType2[\"direct\"] = \"direct\";\n  MutationType2[\"patchObject\"] = \"patch object\";\n  MutationType2[\"patchFunction\"] = \"patch function\";\n})(MutationType || (MutationType = {}));\nconst IS_CLIENT = false;\nconst USE_DEVTOOLS = (process.env.NODE_ENV !== \"production\" || false) && !(process.env.NODE_ENV === \"test\") && IS_CLIENT;\nconst _global = /* @__PURE__ */ (() => false ? void 0 : typeof self === \"object\" && self.self === self ? self : typeof global === \"object\" && global.global === global ? global : typeof globalThis === \"object\" ? globalThis : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n  if (autoBom && /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n    return new Blob([String.fromCharCode(65279), blob], { type: blob.type });\n  }\n  return blob;\n}\nfunction download(url, name, opts) {\n  const xhr = new (void 0)();\n  xhr.open(\"GET\", url);\n  xhr.responseType = \"blob\";\n  xhr.onload = function() {\n    saveAs(xhr.response, name, opts);\n  };\n  xhr.onerror = function() {\n    console.error(\"could not download file\");\n  };\n  xhr.send();\n}\nfunction corsEnabled(url) {\n  const xhr = new (void 0)();\n  xhr.open(\"HEAD\", url, false);\n  try {\n    xhr.send();\n  } catch (e) {\n  }\n  return xhr.status >= 200 && xhr.status <= 299;\n}\nfunction click(node) {\n  try {\n    node.dispatchEvent(new MouseEvent(\"click\"));\n  } catch (e) {\n    const evt = (void 0).createEvent(\"MouseEvents\");\n    evt.initMouseEvent(\"click\", true, true, void 0, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n    node.dispatchEvent(evt);\n  }\n}\nconst _navigator = false ? void 0 : { userAgent: \"\" };\nconst isMacOSWebView = /* @__PURE__ */ (() => /Macintosh/.test(_navigator.userAgent) && /AppleWebKit/.test(_navigator.userAgent) && !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT ? () => {\n} : (\n  // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n  typeof HTMLAnchorElement !== \"undefined\" && \"download\" in HTMLAnchorElement.prototype && !isMacOSWebView ? downloadSaveAs : (\n    // Use msSaveOrOpenBlob as a second approach\n    \"msSaveOrOpenBlob\" in _navigator ? msSaveAs : (\n      // Fallback to using FileReader and a popup\n      fileSaverSaveAs\n    )\n  )\n);\nfunction downloadSaveAs(blob, name = \"download\", opts) {\n  const a = (void 0).createElement(\"a\");\n  a.download = name;\n  a.rel = \"noopener\";\n  if (typeof blob === \"string\") {\n    a.href = blob;\n    if (a.origin !== (void 0).origin) {\n      if (corsEnabled(a.href)) {\n        download(blob, name, opts);\n      } else {\n        a.target = \"_blank\";\n        click(a);\n      }\n    } else {\n      click(a);\n    }\n  } else {\n    a.href = URL.createObjectURL(blob);\n    setTimeout(function() {\n      URL.revokeObjectURL(a.href);\n    }, 4e4);\n    setTimeout(function() {\n      click(a);\n    }, 0);\n  }\n}\nfunction msSaveAs(blob, name = \"download\", opts) {\n  if (typeof blob === \"string\") {\n    if (corsEnabled(blob)) {\n      download(blob, name, opts);\n    } else {\n      const a = (void 0).createElement(\"a\");\n      a.href = blob;\n      a.target = \"_blank\";\n      setTimeout(function() {\n        click(a);\n      });\n    }\n  } else {\n    (void 0).msSaveOrOpenBlob(bom(blob, opts), name);\n  }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n  popup = popup || open(\"\", \"_blank\");\n  if (popup) {\n    popup.document.title = popup.document.body.innerText = \"downloading...\";\n  }\n  if (typeof blob === \"string\")\n    return download(blob, name, opts);\n  const force = blob.type === \"application/octet-stream\";\n  const isSafari = /constructor/i.test(String(_global.HTMLElement)) || \"safari\" in _global;\n  const isChromeIOS = /CriOS\\/[\\d]+/.test((void 0).userAgent);\n  if ((isChromeIOS || force && isSafari || isMacOSWebView) && typeof FileReader !== \"undefined\") {\n    const reader = new FileReader();\n    reader.onloadend = function() {\n      let url = reader.result;\n      if (typeof url !== \"string\") {\n        popup = null;\n        throw new Error(\"Wrong reader.result type\");\n      }\n      url = isChromeIOS ? url : url.replace(/^data:[^;]*;/, \"data:attachment/file;\");\n      if (popup) {\n        popup.location.href = url;\n      } else {\n        (void 0).assign(url);\n      }\n      popup = null;\n    };\n    reader.readAsDataURL(blob);\n  } else {\n    const url = URL.createObjectURL(blob);\n    if (popup)\n      popup.location.assign(url);\n    else\n      (void 0).href = url;\n    popup = null;\n    setTimeout(function() {\n      URL.revokeObjectURL(url);\n    }, 4e4);\n  }\n}\nfunction toastMessage(message, type) {\n  const piniaMessage = \"🍍 \" + message;\n  if (typeof __VUE_DEVTOOLS_TOAST__ === \"function\") {\n    __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n  } else if (type === \"error\") {\n    console.error(piniaMessage);\n  } else if (type === \"warn\") {\n    console.warn(piniaMessage);\n  } else {\n    console.log(piniaMessage);\n  }\n}\nfunction isPinia(o) {\n  return \"_a\" in o && \"install\" in o;\n}\nfunction checkClipboardAccess() {\n  if (!(\"clipboard\" in void 0)) {\n    toastMessage(`Your browser doesn't support the Clipboard API`, \"error\");\n    return true;\n  }\n}\nfunction checkNotFocusedError(error) {\n  if (error instanceof Error && error.message.toLowerCase().includes(\"document is not focused\")) {\n    toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', \"warn\");\n    return true;\n  }\n  return false;\n}\nasync function actionGlobalCopyState(pinia) {\n  if (checkClipboardAccess())\n    return;\n  try {\n    await (void 0).clipboard.writeText(JSON.stringify(pinia.state.value));\n    toastMessage(\"Global state copied to clipboard.\");\n  } catch (error) {\n    if (checkNotFocusedError(error))\n      return;\n    toastMessage(`Failed to serialize the state. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nasync function actionGlobalPasteState(pinia) {\n  if (checkClipboardAccess())\n    return;\n  try {\n    loadStoresState(pinia, JSON.parse(await (void 0).clipboard.readText()));\n    toastMessage(\"Global state pasted from clipboard.\");\n  } catch (error) {\n    if (checkNotFocusedError(error))\n      return;\n    toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nasync function actionGlobalSaveState(pinia) {\n  try {\n    saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n      type: \"text/plain;charset=utf-8\"\n    }), \"pinia-state.json\");\n  } catch (error) {\n    toastMessage(`Failed to export the state as JSON. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nlet fileInput;\nfunction getFileOpener() {\n  if (!fileInput) {\n    fileInput = (void 0).createElement(\"input\");\n    fileInput.type = \"file\";\n    fileInput.accept = \".json\";\n  }\n  function openFile() {\n    return new Promise((resolve, reject) => {\n      fileInput.onchange = async () => {\n        const files = fileInput.files;\n        if (!files)\n          return resolve(null);\n        const file = files.item(0);\n        if (!file)\n          return resolve(null);\n        return resolve({ text: await file.text(), file });\n      };\n      fileInput.oncancel = () => resolve(null);\n      fileInput.onerror = reject;\n      fileInput.click();\n    });\n  }\n  return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n  try {\n    const open2 = getFileOpener();\n    const result = await open2();\n    if (!result)\n      return;\n    const { text, file } = result;\n    loadStoresState(pinia, JSON.parse(text));\n    toastMessage(`Global state imported from \"${file.name}\".`);\n  } catch (error) {\n    toastMessage(`Failed to import the state from JSON. Check the console for more details.`, \"error\");\n    console.error(error);\n  }\n}\nfunction loadStoresState(pinia, state) {\n  for (const key in state) {\n    const storeState = pinia.state.value[key];\n    if (storeState) {\n      Object.assign(storeState, state[key]);\n    } else {\n      pinia.state.value[key] = state[key];\n    }\n  }\n}\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n}\nconst PINIA_ROOT_LABEL = \"🍍 Pinia (root)\";\nconst PINIA_ROOT_ID = \"_root\";\nfunction formatStoreForInspectorTree(store) {\n  return isPinia(store) ? {\n    id: PINIA_ROOT_ID,\n    label: PINIA_ROOT_LABEL\n  } : {\n    id: store.$id,\n    label: store.$id\n  };\n}\nfunction formatStoreForInspectorState(store) {\n  if (isPinia(store)) {\n    const storeNames = Array.from(store._s.keys());\n    const storeMap = store._s;\n    const state2 = {\n      state: storeNames.map((storeId) => ({\n        editable: true,\n        key: storeId,\n        value: store.state.value[storeId]\n      })),\n      getters: storeNames.filter((id) => storeMap.get(id)._getters).map((id) => {\n        const store2 = storeMap.get(id);\n        return {\n          editable: false,\n          key: id,\n          value: store2._getters.reduce((getters, key) => {\n            getters[key] = store2[key];\n            return getters;\n          }, {})\n        };\n      })\n    };\n    return state2;\n  }\n  const state = {\n    state: Object.keys(store.$state).map((key) => ({\n      editable: true,\n      key,\n      value: store.$state[key]\n    }))\n  };\n  if (store._getters && store._getters.length) {\n    state.getters = store._getters.map((getterName) => ({\n      editable: false,\n      key: getterName,\n      value: store[getterName]\n    }));\n  }\n  if (store._customProperties.size) {\n    state.customProperties = Array.from(store._customProperties).map((key) => ({\n      editable: true,\n      key,\n      value: store[key]\n    }));\n  }\n  return state;\n}\nfunction formatEventData(events) {\n  if (!events)\n    return {};\n  if (Array.isArray(events)) {\n    return events.reduce((data, event) => {\n      data.keys.push(event.key);\n      data.operations.push(event.type);\n      data.oldValue[event.key] = event.oldValue;\n      data.newValue[event.key] = event.newValue;\n      return data;\n    }, {\n      oldValue: {},\n      keys: [],\n      operations: [],\n      newValue: {}\n    });\n  } else {\n    return {\n      operation: formatDisplay(events.type),\n      key: formatDisplay(events.key),\n      oldValue: events.oldValue,\n      newValue: events.newValue\n    };\n  }\n}\nfunction formatMutationType(type) {\n  switch (type) {\n    case MutationType.direct:\n      return \"mutation\";\n    case MutationType.patchFunction:\n      return \"$patch\";\n    case MutationType.patchObject:\n      return \"$patch\";\n    default:\n      return \"unknown\";\n  }\n}\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = \"pinia:mutations\";\nconst INSPECTOR_ID = \"pinia\";\nconst { assign: assign$1 } = Object;\nconst getStoreType = (id) => \"🍍 \" + id;\nfunction registerPiniaDevtools(app, pinia) {\n  setupDevtoolsPlugin({\n    id: \"dev.esm.pinia\",\n    label: \"Pinia 🍍\",\n    logo: \"https://pinia.vuejs.org/logo.svg\",\n    packageName: \"pinia\",\n    homepage: \"https://pinia.vuejs.org\",\n    componentStateTypes,\n    app\n  }, (api) => {\n    if (typeof api.now !== \"function\") {\n      toastMessage(\"You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.\");\n    }\n    api.addTimelineLayer({\n      id: MUTATIONS_LAYER_ID,\n      label: `Pinia 🍍`,\n      color: 15064968\n    });\n    api.addInspector({\n      id: INSPECTOR_ID,\n      label: \"Pinia 🍍\",\n      icon: \"storage\",\n      treeFilterPlaceholder: \"Search stores\",\n      actions: [\n        {\n          icon: \"content_copy\",\n          action: () => {\n            actionGlobalCopyState(pinia);\n          },\n          tooltip: \"Serialize and copy the state\"\n        },\n        {\n          icon: \"content_paste\",\n          action: async () => {\n            await actionGlobalPasteState(pinia);\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n          },\n          tooltip: \"Replace the state with the content of your clipboard\"\n        },\n        {\n          icon: \"save\",\n          action: () => {\n            actionGlobalSaveState(pinia);\n          },\n          tooltip: \"Save the state as a JSON file\"\n        },\n        {\n          icon: \"folder_open\",\n          action: async () => {\n            await actionGlobalOpenStateFile(pinia);\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n          },\n          tooltip: \"Import the state from a JSON file\"\n        }\n      ],\n      nodeActions: [\n        {\n          icon: \"restore\",\n          tooltip: 'Reset the state (with \"$reset\")',\n          action: (nodeId) => {\n            const store = pinia._s.get(nodeId);\n            if (!store) {\n              toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, \"warn\");\n            } else if (typeof store.$reset !== \"function\") {\n              toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, \"warn\");\n            } else {\n              store.$reset();\n              toastMessage(`Store \"${nodeId}\" reset.`);\n            }\n          }\n        }\n      ]\n    });\n    api.on.inspectComponent((payload, ctx) => {\n      const proxy = payload.componentInstance && payload.componentInstance.proxy;\n      if (proxy && proxy._pStores) {\n        const piniaStores = payload.componentInstance.proxy._pStores;\n        Object.values(piniaStores).forEach((store) => {\n          payload.instanceData.state.push({\n            type: getStoreType(store.$id),\n            key: \"state\",\n            editable: true,\n            value: store._isOptionsAPI ? {\n              _custom: {\n                value: toRaw(store.$state),\n                actions: [\n                  {\n                    icon: \"restore\",\n                    tooltip: \"Reset the state of this store\",\n                    action: () => store.$reset()\n                  }\n                ]\n              }\n            } : (\n              // NOTE: workaround to unwrap transferred refs\n              Object.keys(store.$state).reduce((state, key) => {\n                state[key] = store.$state[key];\n                return state;\n              }, {})\n            )\n          });\n          if (store._getters && store._getters.length) {\n            payload.instanceData.state.push({\n              type: getStoreType(store.$id),\n              key: \"getters\",\n              editable: false,\n              value: store._getters.reduce((getters, key) => {\n                try {\n                  getters[key] = store[key];\n                } catch (error) {\n                  getters[key] = error;\n                }\n                return getters;\n              }, {})\n            });\n          }\n        });\n      }\n    });\n    api.on.getInspectorTree((payload) => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        let stores = [pinia];\n        stores = stores.concat(Array.from(pinia._s.values()));\n        payload.rootNodes = (payload.filter ? stores.filter((store) => \"$id\" in store ? store.$id.toLowerCase().includes(payload.filter.toLowerCase()) : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase())) : stores).map(formatStoreForInspectorTree);\n      }\n    });\n    api.on.getInspectorState((payload) => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);\n        if (!inspectedStore) {\n          return;\n        }\n        if (inspectedStore) {\n          payload.state = formatStoreForInspectorState(inspectedStore);\n        }\n      }\n    });\n    api.on.editInspectorState((payload, ctx) => {\n      if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n        const inspectedStore = payload.nodeId === PINIA_ROOT_ID ? pinia : pinia._s.get(payload.nodeId);\n        if (!inspectedStore) {\n          return toastMessage(`store \"${payload.nodeId}\" not found`, \"error\");\n        }\n        const { path } = payload;\n        if (!isPinia(inspectedStore)) {\n          if (path.length !== 1 || !inspectedStore._customProperties.has(path[0]) || path[0] in inspectedStore.$state) {\n            path.unshift(\"$state\");\n          }\n        } else {\n          path.unshift(\"state\");\n        }\n        isTimelineActive = false;\n        payload.set(inspectedStore, path, payload.state.value);\n        isTimelineActive = true;\n      }\n    });\n    api.on.editComponentState((payload) => {\n      if (payload.type.startsWith(\"🍍\")) {\n        const storeId = payload.type.replace(/^🍍\\s*/, \"\");\n        const store = pinia._s.get(storeId);\n        if (!store) {\n          return toastMessage(`store \"${storeId}\" not found`, \"error\");\n        }\n        const { path } = payload;\n        if (path[0] !== \"state\") {\n          return toastMessage(`Invalid path for store \"${storeId}\":\n${path}\nOnly state can be modified.`);\n        }\n        path[0] = \"$state\";\n        isTimelineActive = false;\n        payload.set(store, path, payload.state.value);\n        isTimelineActive = true;\n      }\n    });\n  });\n}\nfunction addStoreToDevtools(app, store) {\n  if (!componentStateTypes.includes(getStoreType(store.$id))) {\n    componentStateTypes.push(getStoreType(store.$id));\n  }\n  setupDevtoolsPlugin({\n    id: \"dev.esm.pinia\",\n    label: \"Pinia 🍍\",\n    logo: \"https://pinia.vuejs.org/logo.svg\",\n    packageName: \"pinia\",\n    homepage: \"https://pinia.vuejs.org\",\n    componentStateTypes,\n    app,\n    settings: {\n      logStoreChanges: {\n        label: \"Notify about new/deleted stores\",\n        type: \"boolean\",\n        defaultValue: true\n      }\n      // useEmojis: {\n      //   label: 'Use emojis in messages ⚡️',\n      //   type: 'boolean',\n      //   defaultValue: true,\n      // },\n    }\n  }, (api) => {\n    const now = typeof api.now === \"function\" ? api.now.bind(api) : Date.now;\n    store.$onAction(({ after, onError, name, args }) => {\n      const groupId = runningActionId++;\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: {\n          time: now(),\n          title: \"🛫 \" + name,\n          subtitle: \"start\",\n          data: {\n            store: formatDisplay(store.$id),\n            action: formatDisplay(name),\n            args\n          },\n          groupId\n        }\n      });\n      after((result) => {\n        activeAction = void 0;\n        api.addTimelineEvent({\n          layerId: MUTATIONS_LAYER_ID,\n          event: {\n            time: now(),\n            title: \"🛬 \" + name,\n            subtitle: \"end\",\n            data: {\n              store: formatDisplay(store.$id),\n              action: formatDisplay(name),\n              args,\n              result\n            },\n            groupId\n          }\n        });\n      });\n      onError((error) => {\n        activeAction = void 0;\n        api.addTimelineEvent({\n          layerId: MUTATIONS_LAYER_ID,\n          event: {\n            time: now(),\n            logType: \"error\",\n            title: \"💥 \" + name,\n            subtitle: \"end\",\n            data: {\n              store: formatDisplay(store.$id),\n              action: formatDisplay(name),\n              args,\n              error\n            },\n            groupId\n          }\n        });\n      });\n    }, true);\n    store._customProperties.forEach((name) => {\n      watch(() => unref(store[name]), (newValue, oldValue) => {\n        api.notifyComponentUpdate();\n        api.sendInspectorState(INSPECTOR_ID);\n        if (isTimelineActive) {\n          api.addTimelineEvent({\n            layerId: MUTATIONS_LAYER_ID,\n            event: {\n              time: now(),\n              title: \"Change\",\n              subtitle: name,\n              data: {\n                newValue,\n                oldValue\n              },\n              groupId: activeAction\n            }\n          });\n        }\n      }, { deep: true });\n    });\n    store.$subscribe(({ events, type }, state) => {\n      api.notifyComponentUpdate();\n      api.sendInspectorState(INSPECTOR_ID);\n      if (!isTimelineActive)\n        return;\n      const eventData = {\n        time: now(),\n        title: formatMutationType(type),\n        data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n        groupId: activeAction\n      };\n      if (type === MutationType.patchFunction) {\n        eventData.subtitle = \"⤵️\";\n      } else if (type === MutationType.patchObject) {\n        eventData.subtitle = \"🧩\";\n      } else if (events && !Array.isArray(events)) {\n        eventData.subtitle = events.type;\n      }\n      if (events) {\n        eventData.data[\"rawEvent(s)\"] = {\n          _custom: {\n            display: \"DebuggerEvent\",\n            type: \"object\",\n            tooltip: \"raw DebuggerEvent[]\",\n            value: events\n          }\n        };\n      }\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: eventData\n      });\n    }, { detached: true, flush: \"sync\" });\n    const hotUpdate = store._hotUpdate;\n    store._hotUpdate = markRaw((newStore) => {\n      hotUpdate(newStore);\n      api.addTimelineEvent({\n        layerId: MUTATIONS_LAYER_ID,\n        event: {\n          time: now(),\n          title: \"🔥 \" + store.$id,\n          subtitle: \"HMR update\",\n          data: {\n            store: formatDisplay(store.$id),\n            info: formatDisplay(`HMR update`)\n          }\n        }\n      });\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(INSPECTOR_ID);\n      api.sendInspectorState(INSPECTOR_ID);\n    });\n    const { $dispose } = store;\n    store.$dispose = () => {\n      $dispose();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(INSPECTOR_ID);\n      api.sendInspectorState(INSPECTOR_ID);\n      api.getSettings().logStoreChanges && toastMessage(`Disposed \"${store.$id}\" store 🗑`);\n    };\n    api.notifyComponentUpdate();\n    api.sendInspectorTree(INSPECTOR_ID);\n    api.sendInspectorState(INSPECTOR_ID);\n    api.getSettings().logStoreChanges && toastMessage(`\"${store.$id}\" store installed 🆕`);\n  });\n}\nlet runningActionId = 0;\nlet activeAction;\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n  const actions = actionNames.reduce((storeActions, actionName) => {\n    storeActions[actionName] = toRaw(store)[actionName];\n    return storeActions;\n  }, {});\n  for (const actionName in actions) {\n    store[actionName] = function() {\n      const _actionId = runningActionId;\n      const trackedStore = wrapWithProxy ? new Proxy(store, {\n        get(...args) {\n          activeAction = _actionId;\n          return Reflect.get(...args);\n        },\n        set(...args) {\n          activeAction = _actionId;\n          return Reflect.set(...args);\n        }\n      }) : store;\n      activeAction = _actionId;\n      const retValue = actions[actionName].apply(trackedStore, arguments);\n      activeAction = void 0;\n      return retValue;\n    };\n  }\n}\nfunction devtoolsPlugin({ app, store, options }) {\n  if (store.$id.startsWith(\"__hot:\")) {\n    return;\n  }\n  store._isOptionsAPI = !!options.state;\n  patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n  const originalHotUpdate = store._hotUpdate;\n  toRaw(store)._hotUpdate = function(newStore) {\n    originalHotUpdate.apply(this, arguments);\n    patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n  };\n  addStoreToDevtools(\n    app,\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store\n  );\n}\nfunction createPinia() {\n  const scope = effectScope(true);\n  const state = scope.run(() => ref({}));\n  let _p = [];\n  let toBeInstalled = [];\n  const pinia = markRaw({\n    install(app) {\n      setActivePinia(pinia);\n      if (!isVue2) {\n        pinia._a = app;\n        app.provide(piniaSymbol, pinia);\n        app.config.globalProperties.$pinia = pinia;\n        if (USE_DEVTOOLS) {\n          registerPiniaDevtools(app, pinia);\n        }\n        toBeInstalled.forEach((plugin) => _p.push(plugin));\n        toBeInstalled = [];\n      }\n    },\n    use(plugin) {\n      if (!this._a && !isVue2) {\n        toBeInstalled.push(plugin);\n      } else {\n        _p.push(plugin);\n      }\n      return this;\n    },\n    _p,\n    // it's actually undefined here\n    // @ts-expect-error\n    _a: null,\n    _e: scope,\n    _s: /* @__PURE__ */ new Map(),\n    state\n  });\n  if (USE_DEVTOOLS && typeof Proxy !== \"undefined\") {\n    pinia.use(devtoolsPlugin);\n  }\n  return pinia;\n}\nconst isUseStore = (fn) => {\n  return typeof fn === \"function\" && typeof fn.$id === \"string\";\n};\nfunction patchObject(newState, oldState) {\n  for (const key in oldState) {\n    const subPatch = oldState[key];\n    if (!(key in newState)) {\n      continue;\n    }\n    const targetValue = newState[key];\n    if (isPlainObject(targetValue) && isPlainObject(subPatch) && !isRef(subPatch) && !isReactive(subPatch)) {\n      newState[key] = patchObject(targetValue, subPatch);\n    } else {\n      if (isVue2) {\n        set(newState, key, subPatch);\n      } else {\n        newState[key] = subPatch;\n      }\n    }\n  }\n  return newState;\n}\nfunction acceptHMRUpdate(initialUseStore, hot) {\n  if (!(process.env.NODE_ENV !== \"production\")) {\n    return () => {\n    };\n  }\n  return (newModule) => {\n    const pinia = hot.data.pinia || initialUseStore._pinia;\n    if (!pinia) {\n      return;\n    }\n    hot.data.pinia = pinia;\n    for (const exportName in newModule) {\n      const useStore = newModule[exportName];\n      if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n        const id = useStore.$id;\n        if (id !== initialUseStore.$id) {\n          console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n          return hot.invalidate();\n        }\n        const existingStore = pinia._s.get(id);\n        if (!existingStore) {\n          console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n          return;\n        }\n        useStore(pinia, existingStore);\n      }\n    }\n  };\n}\nconst noop = () => {\n};\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n  subscriptions.push(callback);\n  const removeSubscription = () => {\n    const idx = subscriptions.indexOf(callback);\n    if (idx > -1) {\n      subscriptions.splice(idx, 1);\n      onCleanup();\n    }\n  };\n  if (!detached && getCurrentScope()) {\n    onScopeDispose(removeSubscription);\n  }\n  return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n  subscriptions.slice().forEach((callback) => {\n    callback(...args);\n  });\n}\nconst fallbackRunWithContext = (fn) => fn();\nfunction mergeReactiveObjects(target, patchToApply) {\n  if (target instanceof Map && patchToApply instanceof Map) {\n    patchToApply.forEach((value, key) => target.set(key, value));\n  }\n  if (target instanceof Set && patchToApply instanceof Set) {\n    patchToApply.forEach(target.add, target);\n  }\n  for (const key in patchToApply) {\n    if (!patchToApply.hasOwnProperty(key))\n      continue;\n    const subPatch = patchToApply[key];\n    const targetValue = target[key];\n    if (isPlainObject(targetValue) && isPlainObject(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {\n      target[key] = mergeReactiveObjects(targetValue, subPatch);\n    } else {\n      target[key] = subPatch;\n    }\n  }\n  return target;\n}\nconst skipHydrateSymbol = process.env.NODE_ENV !== \"production\" ? Symbol(\"pinia:skipHydration\") : (\n  /* istanbul ignore next */\n  Symbol()\n);\nconst skipHydrateMap = /* @__PURE__ */ new WeakMap();\nfunction skipHydrate(obj) {\n  return isVue2 ? (\n    // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n    /* istanbul ignore next */\n    skipHydrateMap.set(obj, 1) && obj\n  ) : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\nfunction shouldHydrate(obj) {\n  return isVue2 ? (\n    /* istanbul ignore next */\n    !skipHydrateMap.has(obj)\n  ) : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n  return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n  const { state, actions, getters } = options;\n  const initialState = pinia.state.value[id];\n  let store;\n  function setup() {\n    if (!initialState && (!(process.env.NODE_ENV !== \"production\") || !hot)) {\n      if (isVue2) {\n        set(pinia.state.value, id, state ? state() : {});\n      } else {\n        pinia.state.value[id] = state ? state() : {};\n      }\n    }\n    const localState = process.env.NODE_ENV !== \"production\" && hot ? (\n      // use ref() to unwrap refs inside state TODO: check if this is still necessary\n      toRefs(ref(state ? state() : {}).value)\n    ) : toRefs(pinia.state.value[id]);\n    return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n      if (process.env.NODE_ENV !== \"production\" && name in localState) {\n        console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n      }\n      computedGetters[name] = markRaw(computed(() => {\n        setActivePinia(pinia);\n        const store2 = pinia._s.get(id);\n        if (isVue2 && !store2._r)\n          return;\n        return getters[name].call(store2, store2);\n      }));\n      return computedGetters;\n    }, {}));\n  }\n  store = createSetupStore(id, setup, options, pinia, hot, true);\n  return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n  let scope;\n  const optionsForPlugin = assign({ actions: {} }, options);\n  if (process.env.NODE_ENV !== \"production\" && !pinia._e.active) {\n    throw new Error(\"Pinia destroyed\");\n  }\n  const $subscribeOptions = {\n    deep: true\n    // flush: 'post',\n  };\n  if (process.env.NODE_ENV !== \"production\" && !isVue2) {\n    $subscribeOptions.onTrigger = (event) => {\n      if (isListening) {\n        debuggerEvents = event;\n      } else if (isListening == false && !store._hotUpdating) {\n        if (Array.isArray(debuggerEvents)) {\n          debuggerEvents.push(event);\n        } else {\n          console.error(\"🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.\");\n        }\n      }\n    };\n  }\n  let isListening;\n  let isSyncListening;\n  let subscriptions = [];\n  let actionSubscriptions = [];\n  let debuggerEvents;\n  const initialState = pinia.state.value[$id];\n  if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== \"production\") || !hot)) {\n    if (isVue2) {\n      set(pinia.state.value, $id, {});\n    } else {\n      pinia.state.value[$id] = {};\n    }\n  }\n  const hotState = ref({});\n  let activeListener;\n  function $patch(partialStateOrMutator) {\n    let subscriptionMutation;\n    isListening = isSyncListening = false;\n    if (process.env.NODE_ENV !== \"production\") {\n      debuggerEvents = [];\n    }\n    if (typeof partialStateOrMutator === \"function\") {\n      partialStateOrMutator(pinia.state.value[$id]);\n      subscriptionMutation = {\n        type: MutationType.patchFunction,\n        storeId: $id,\n        events: debuggerEvents\n      };\n    } else {\n      mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n      subscriptionMutation = {\n        type: MutationType.patchObject,\n        payload: partialStateOrMutator,\n        storeId: $id,\n        events: debuggerEvents\n      };\n    }\n    const myListenerId = activeListener = Symbol();\n    nextTick().then(() => {\n      if (activeListener === myListenerId) {\n        isListening = true;\n      }\n    });\n    isSyncListening = true;\n    triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n  }\n  const $reset = isOptionsStore ? function $reset2() {\n    const { state } = options;\n    const newState = state ? state() : {};\n    this.$patch(($state) => {\n      assign($state, newState);\n    });\n  } : (\n    /* istanbul ignore next */\n    process.env.NODE_ENV !== \"production\" ? () => {\n      throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n    } : noop\n  );\n  function $dispose() {\n    scope.stop();\n    subscriptions = [];\n    actionSubscriptions = [];\n    pinia._s.delete($id);\n  }\n  function wrapAction(name, action) {\n    return function() {\n      setActivePinia(pinia);\n      const args = Array.from(arguments);\n      const afterCallbackList = [];\n      const onErrorCallbackList = [];\n      function after(callback) {\n        afterCallbackList.push(callback);\n      }\n      function onError(callback) {\n        onErrorCallbackList.push(callback);\n      }\n      triggerSubscriptions(actionSubscriptions, {\n        args,\n        name,\n        store,\n        after,\n        onError\n      });\n      let ret;\n      try {\n        ret = action.apply(this && this.$id === $id ? this : store, args);\n      } catch (error) {\n        triggerSubscriptions(onErrorCallbackList, error);\n        throw error;\n      }\n      if (ret instanceof Promise) {\n        return ret.then((value) => {\n          triggerSubscriptions(afterCallbackList, value);\n          return value;\n        }).catch((error) => {\n          triggerSubscriptions(onErrorCallbackList, error);\n          return Promise.reject(error);\n        });\n      }\n      triggerSubscriptions(afterCallbackList, ret);\n      return ret;\n    };\n  }\n  const _hmrPayload = /* @__PURE__ */ markRaw({\n    actions: {},\n    getters: {},\n    state: [],\n    hotState\n  });\n  const partialStore = {\n    _p: pinia,\n    // _s: scope,\n    $id,\n    $onAction: addSubscription.bind(null, actionSubscriptions),\n    $patch,\n    $reset,\n    $subscribe(callback, options2 = {}) {\n      const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());\n      const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n        if (options2.flush === \"sync\" ? isSyncListening : isListening) {\n          callback({\n            storeId: $id,\n            type: MutationType.direct,\n            events: debuggerEvents\n          }, state);\n        }\n      }, assign({}, $subscribeOptions, options2)));\n      return removeSubscription;\n    },\n    $dispose\n  };\n  if (isVue2) {\n    partialStore._r = false;\n  }\n  const store = reactive(process.env.NODE_ENV !== \"production\" || USE_DEVTOOLS ? assign(\n    {\n      _hmrPayload,\n      _customProperties: markRaw(/* @__PURE__ */ new Set())\n      // devtools custom properties\n    },\n    partialStore\n    // must be added later\n    // setupStore\n  ) : partialStore);\n  pinia._s.set($id, store);\n  const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;\n  const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));\n  for (const key in setupStore) {\n    const prop = setupStore[key];\n    if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {\n      if (process.env.NODE_ENV !== \"production\" && hot) {\n        set(hotState.value, key, toRef(setupStore, key));\n      } else if (!isOptionsStore) {\n        if (initialState && shouldHydrate(prop)) {\n          if (isRef(prop)) {\n            prop.value = initialState[key];\n          } else {\n            mergeReactiveObjects(prop, initialState[key]);\n          }\n        }\n        if (isVue2) {\n          set(pinia.state.value[$id], key, prop);\n        } else {\n          pinia.state.value[$id][key] = prop;\n        }\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        _hmrPayload.state.push(key);\n      }\n    } else if (typeof prop === \"function\") {\n      const actionValue = process.env.NODE_ENV !== \"production\" && hot ? prop : wrapAction(key, prop);\n      if (isVue2) {\n        set(setupStore, key, actionValue);\n      } else {\n        setupStore[key] = actionValue;\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        _hmrPayload.actions[key] = prop;\n      }\n      optionsForPlugin.actions[key] = prop;\n    } else if (process.env.NODE_ENV !== \"production\") {\n      if (isComputed(prop)) {\n        _hmrPayload.getters[key] = isOptionsStore ? (\n          // @ts-expect-error\n          options.getters[key]\n        ) : prop;\n        if (IS_CLIENT) {\n          const getters = setupStore._getters || // @ts-expect-error: same\n          (setupStore._getters = markRaw([]));\n          getters.push(key);\n        }\n      }\n    }\n  }\n  if (isVue2) {\n    Object.keys(setupStore).forEach((key) => {\n      set(store, key, setupStore[key]);\n    });\n  } else {\n    assign(store, setupStore);\n    assign(toRaw(store), setupStore);\n  }\n  Object.defineProperty(store, \"$state\", {\n    get: () => process.env.NODE_ENV !== \"production\" && hot ? hotState.value : pinia.state.value[$id],\n    set: (state) => {\n      if (process.env.NODE_ENV !== \"production\" && hot) {\n        throw new Error(\"cannot set hotState\");\n      }\n      $patch(($state) => {\n        assign($state, state);\n      });\n    }\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    store._hotUpdate = markRaw((newStore) => {\n      store._hotUpdating = true;\n      newStore._hmrPayload.state.forEach((stateKey) => {\n        if (stateKey in store.$state) {\n          const newStateTarget = newStore.$state[stateKey];\n          const oldStateSource = store.$state[stateKey];\n          if (typeof newStateTarget === \"object\" && isPlainObject(newStateTarget) && isPlainObject(oldStateSource)) {\n            patchObject(newStateTarget, oldStateSource);\n          } else {\n            newStore.$state[stateKey] = oldStateSource;\n          }\n        }\n        set(store, stateKey, toRef(newStore.$state, stateKey));\n      });\n      Object.keys(store.$state).forEach((stateKey) => {\n        if (!(stateKey in newStore.$state)) {\n          del(store, stateKey);\n        }\n      });\n      isListening = false;\n      isSyncListening = false;\n      pinia.state.value[$id] = toRef(newStore._hmrPayload, \"hotState\");\n      isSyncListening = true;\n      nextTick().then(() => {\n        isListening = true;\n      });\n      for (const actionName in newStore._hmrPayload.actions) {\n        const action = newStore[actionName];\n        set(store, actionName, wrapAction(actionName, action));\n      }\n      for (const getterName in newStore._hmrPayload.getters) {\n        const getter = newStore._hmrPayload.getters[getterName];\n        const getterValue = isOptionsStore ? (\n          // special handling of options api\n          computed(() => {\n            setActivePinia(pinia);\n            return getter.call(store, store);\n          })\n        ) : getter;\n        set(store, getterName, getterValue);\n      }\n      Object.keys(store._hmrPayload.getters).forEach((key) => {\n        if (!(key in newStore._hmrPayload.getters)) {\n          del(store, key);\n        }\n      });\n      Object.keys(store._hmrPayload.actions).forEach((key) => {\n        if (!(key in newStore._hmrPayload.actions)) {\n          del(store, key);\n        }\n      });\n      store._hmrPayload = newStore._hmrPayload;\n      store._getters = newStore._getters;\n      store._hotUpdating = false;\n    });\n  }\n  if (USE_DEVTOOLS) {\n    const nonEnumerable = {\n      writable: true,\n      configurable: true,\n      // avoid warning on devtools trying to display this property\n      enumerable: false\n    };\n    [\"_p\", \"_hmrPayload\", \"_getters\", \"_customProperties\"].forEach((p) => {\n      Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n    });\n  }\n  if (isVue2) {\n    store._r = true;\n  }\n  pinia._p.forEach((extender) => {\n    if (USE_DEVTOOLS) {\n      const extensions = scope.run(() => extender({\n        store,\n        app: pinia._a,\n        pinia,\n        options: optionsForPlugin\n      }));\n      Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n      assign(store, extensions);\n    } else {\n      assign(store, scope.run(() => extender({\n        store,\n        app: pinia._a,\n        pinia,\n        options: optionsForPlugin\n      })));\n    }\n  });\n  if (process.env.NODE_ENV !== \"production\" && store.$state && typeof store.$state === \"object\" && typeof store.$state.constructor === \"function\" && !store.$state.constructor.toString().includes(\"[native code]\")) {\n    console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\n\tstate: () => new MyClass()\nFound in store \"${store.$id}\".`);\n  }\n  if (initialState && isOptionsStore && options.hydrate) {\n    options.hydrate(store.$state, initialState);\n  }\n  isListening = true;\n  isSyncListening = true;\n  return store;\n}\nfunction defineStore(idOrOptions, setup, setupOptions) {\n  let id;\n  let options;\n  const isSetupStore = typeof setup === \"function\";\n  if (typeof idOrOptions === \"string\") {\n    id = idOrOptions;\n    options = isSetupStore ? setupOptions : setup;\n  } else {\n    options = idOrOptions;\n    id = idOrOptions.id;\n    if (process.env.NODE_ENV !== \"production\" && typeof id !== \"string\") {\n      throw new Error(`[🍍]: \"defineStore()\" must be passed a store id as its first argument.`);\n    }\n  }\n  function useStore(pinia, hot) {\n    const hasContext = hasInjectionContext();\n    pinia = // in test mode, ignore the argument provided as we can always retrieve a\n    // pinia instance with getActivePinia()\n    (process.env.NODE_ENV === \"test\" && activePinia && activePinia._testing ? null : pinia) || (hasContext ? inject(piniaSymbol, null) : null);\n    if (pinia)\n      setActivePinia(pinia);\n    if (process.env.NODE_ENV !== \"production\" && !activePinia) {\n      throw new Error(`[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\nSee https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\nThis will fail in production.`);\n    }\n    pinia = activePinia;\n    if (!pinia._s.has(id)) {\n      if (isSetupStore) {\n        createSetupStore(id, setup, options, pinia);\n      } else {\n        createOptionsStore(id, options, pinia);\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        useStore._pinia = pinia;\n      }\n    }\n    const store = pinia._s.get(id);\n    if (process.env.NODE_ENV !== \"production\" && hot) {\n      const hotId = \"__hot:\" + id;\n      const newStore = isSetupStore ? createSetupStore(hotId, setup, options, pinia, true) : createOptionsStore(hotId, assign({}, options), pinia, true);\n      hot._hotUpdate(newStore);\n      delete pinia.state.value[hotId];\n      pinia._s.delete(hotId);\n    }\n    if (process.env.NODE_ENV !== \"production\" && IS_CLIENT) {\n      const currentInstance = getCurrentInstance();\n      if (currentInstance && currentInstance.proxy && // avoid adding stores that are just built for hot module replacement\n      !hot) {\n        const vm = currentInstance.proxy;\n        const cache = \"_pStores\" in vm ? vm._pStores : vm._pStores = {};\n        cache[id] = store;\n      }\n    }\n    return store;\n  }\n  useStore.$id = id;\n  return useStore;\n}\nlet mapStoreSuffix = \"Store\";\nfunction setMapStoreSuffix(suffix) {\n  mapStoreSuffix = suffix;\n}\nfunction mapStores(...stores) {\n  if (process.env.NODE_ENV !== \"production\" && Array.isArray(stores[0])) {\n    console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\nReplace\n\tmapStores([useAuthStore, useCartStore])\nwith\n\tmapStores(useAuthStore, useCartStore)\nThis will fail in production if not fixed.`);\n    stores = stores[0];\n  }\n  return stores.reduce((reduced, useStore) => {\n    reduced[useStore.$id + mapStoreSuffix] = function() {\n      return useStore(this.$pinia);\n    };\n    return reduced;\n  }, {});\n}\nfunction mapState(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    reduced[key] = function() {\n      return useStore(this.$pinia)[key];\n    };\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    reduced[key] = function() {\n      const store = useStore(this.$pinia);\n      const storeKey = keysOrMapper[key];\n      return typeof storeKey === \"function\" ? storeKey.call(this, store) : store[storeKey];\n    };\n    return reduced;\n  }, {});\n}\nconst mapGetters = mapState;\nfunction mapActions(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    reduced[key] = function(...args) {\n      return useStore(this.$pinia)[key](...args);\n    };\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    reduced[key] = function(...args) {\n      return useStore(this.$pinia)[keysOrMapper[key]](...args);\n    };\n    return reduced;\n  }, {});\n}\nfunction mapWritableState(useStore, keysOrMapper) {\n  return Array.isArray(keysOrMapper) ? keysOrMapper.reduce((reduced, key) => {\n    reduced[key] = {\n      get() {\n        return useStore(this.$pinia)[key];\n      },\n      set(value) {\n        return useStore(this.$pinia)[key] = value;\n      }\n    };\n    return reduced;\n  }, {}) : Object.keys(keysOrMapper).reduce((reduced, key) => {\n    reduced[key] = {\n      get() {\n        return useStore(this.$pinia)[keysOrMapper[key]];\n      },\n      set(value) {\n        return useStore(this.$pinia)[keysOrMapper[key]] = value;\n      }\n    };\n    return reduced;\n  }, {});\n}\nfunction storeToRefs(store) {\n  if (isVue2) {\n    return toRefs(store);\n  } else {\n    store = toRaw(store);\n    const refs = {};\n    for (const key in store) {\n      const value = store[key];\n      if (isRef(value) || isReactive(value)) {\n        refs[key] = // ---\n        toRef(store, key);\n      }\n    }\n    return refs;\n  }\n}\nconst PiniaVuePlugin = function(_Vue) {\n  _Vue.mixin({\n    beforeCreate() {\n      const options = this.$options;\n      if (options.pinia) {\n        const pinia = options.pinia;\n        if (!this._provided) {\n          const provideCache = {};\n          Object.defineProperty(this, \"_provided\", {\n            get: () => provideCache,\n            set: (v) => Object.assign(provideCache, v)\n          });\n        }\n        this._provided[piniaSymbol] = pinia;\n        if (!this.$pinia) {\n          this.$pinia = pinia;\n        }\n        pinia._a = this;\n        if (IS_CLIENT) {\n          setActivePinia(pinia);\n        }\n        if (USE_DEVTOOLS) {\n          registerPiniaDevtools(pinia._a, pinia);\n        }\n      } else if (!this.$pinia && options.parent && options.parent.$pinia) {\n        this.$pinia = options.parent.$pinia;\n      }\n    },\n    destroyed() {\n      delete this._pStores;\n    }\n  });\n};\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n",
      "start": 1714315495387,
      "end": 1714315495422,
      "order": "normal",
      "sourcemaps": "{\n  \"version\": 3,\n  \"sources\": [\"C:/Users/h00dy/Documents/github/h00dy.me/node_modules/pinia/dist/pinia.mjs\"],\n  \"sourcesContent\": [\"/*!\\r\\n * pinia v2.1.7\\r\\n * (c) 2023 Eduardo San Martin Morote\\r\\n * @license MIT\\r\\n */\\r\\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\\r\\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\\r\\n\\r\\n/**\\r\\n * setActivePinia must be called to handle SSR at the top of functions like\\r\\n * `fetch`, `setup`, `serverPrefetch` and others\\r\\n */\\r\\nlet activePinia;\\r\\n/**\\r\\n * Sets or unsets the active pinia. Used in SSR and internally when calling\\r\\n * actions and getters\\r\\n *\\r\\n * @param pinia - Pinia instance\\r\\n */\\r\\n// @ts-expect-error: cannot constrain the type of the return\\r\\nconst setActivePinia = (pinia) => (activePinia = pinia);\\r\\n/**\\r\\n * Get the currently active pinia if there is any.\\r\\n */\\r\\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\\r\\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\\r\\n\\r\\nfunction isPlainObject(\\r\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\r\\no) {\\r\\n    return (o &&\\r\\n        typeof o === 'object' &&\\r\\n        Object.prototype.toString.call(o) === '[object Object]' &&\\r\\n        typeof o.toJSON !== 'function');\\r\\n}\\r\\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\\r\\n// TODO: can we change these to numbers?\\r\\n/**\\r\\n * Possible types for SubscriptionCallback\\r\\n */\\r\\nvar MutationType;\\r\\n(function (MutationType) {\\r\\n    /**\\r\\n     * Direct mutation of the state:\\r\\n     *\\r\\n     * - `store.name = 'new name'`\\r\\n     * - `store.$state.name = 'new name'`\\r\\n     * - `store.list.push('new item')`\\r\\n     */\\r\\n    MutationType[\\\"direct\\\"] = \\\"direct\\\";\\r\\n    /**\\r\\n     * Mutated the state with `$patch` and an object\\r\\n     *\\r\\n     * - `store.$patch({ name: 'newName' })`\\r\\n     */\\r\\n    MutationType[\\\"patchObject\\\"] = \\\"patch object\\\";\\r\\n    /**\\r\\n     * Mutated the state with `$patch` and a function\\r\\n     *\\r\\n     * - `store.$patch(state => state.name = 'newName')`\\r\\n     */\\r\\n    MutationType[\\\"patchFunction\\\"] = \\\"patch function\\\";\\r\\n    // maybe reset? for $state = {} and $reset\\r\\n})(MutationType || (MutationType = {}));\\r\\n\\r\\nconst IS_CLIENT = typeof window !== 'undefined';\\r\\n/**\\r\\n * Should we add the devtools plugins.\\r\\n * - only if dev mode or forced through the prod devtools flag\\r\\n * - not in test\\r\\n * - only if window exists (could change in the future)\\r\\n */\\r\\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\\r\\n\\r\\n/*\\r\\n * FileSaver.js A saveAs() FileSaver implementation.\\r\\n *\\r\\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\\r\\n * Morote.\\r\\n *\\r\\n * License : MIT\\r\\n */\\r\\n// The one and only way of getting global scope in all environments\\r\\n// https://stackoverflow.com/q/3277182/1008999\\r\\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\\r\\n    ? window\\r\\n    : typeof self === 'object' && self.self === self\\r\\n        ? self\\r\\n        : typeof global === 'object' && global.global === global\\r\\n            ? global\\r\\n            : typeof globalThis === 'object'\\r\\n                ? globalThis\\r\\n                : { HTMLElement: null })();\\r\\nfunction bom(blob, { autoBom = false } = {}) {\\r\\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\\r\\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\\r\\n    if (autoBom &&\\r\\n        /^\\\\s*(?:text\\\\/\\\\S*|application\\\\/xml|\\\\S*\\\\/\\\\S*\\\\+xml)\\\\s*;.*charset\\\\s*=\\\\s*utf-8/i.test(blob.type)) {\\r\\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\\r\\n    }\\r\\n    return blob;\\r\\n}\\r\\nfunction download(url, name, opts) {\\r\\n    const xhr = new XMLHttpRequest();\\r\\n    xhr.open('GET', url);\\r\\n    xhr.responseType = 'blob';\\r\\n    xhr.onload = function () {\\r\\n        saveAs(xhr.response, name, opts);\\r\\n    };\\r\\n    xhr.onerror = function () {\\r\\n        console.error('could not download file');\\r\\n    };\\r\\n    xhr.send();\\r\\n}\\r\\nfunction corsEnabled(url) {\\r\\n    const xhr = new XMLHttpRequest();\\r\\n    // use sync to avoid popup blocker\\r\\n    xhr.open('HEAD', url, false);\\r\\n    try {\\r\\n        xhr.send();\\r\\n    }\\r\\n    catch (e) { }\\r\\n    return xhr.status >= 200 && xhr.status <= 299;\\r\\n}\\r\\n// `a.click()` doesn't work for all browsers (#465)\\r\\nfunction click(node) {\\r\\n    try {\\r\\n        node.dispatchEvent(new MouseEvent('click'));\\r\\n    }\\r\\n    catch (e) {\\r\\n        const evt = document.createEvent('MouseEvents');\\r\\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\\r\\n        node.dispatchEvent(evt);\\r\\n    }\\r\\n}\\r\\nconst _navigator = \\r\\n typeof navigator === 'object' ? navigator : { userAgent: '' };\\r\\n// Detect WebView inside a native macOS app by ruling out all browsers\\r\\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\\r\\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\\r\\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\\r\\n    /AppleWebKit/.test(_navigator.userAgent) &&\\r\\n    !/Safari/.test(_navigator.userAgent))();\\r\\nconst saveAs = !IS_CLIENT\\r\\n    ? () => { } // noop\\r\\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\\r\\n        typeof HTMLAnchorElement !== 'undefined' &&\\r\\n            'download' in HTMLAnchorElement.prototype &&\\r\\n            !isMacOSWebView\\r\\n            ? downloadSaveAs\\r\\n            : // Use msSaveOrOpenBlob as a second approach\\r\\n                'msSaveOrOpenBlob' in _navigator\\r\\n                    ? msSaveAs\\r\\n                    : // Fallback to using FileReader and a popup\\r\\n                        fileSaverSaveAs;\\r\\nfunction downloadSaveAs(blob, name = 'download', opts) {\\r\\n    const a = document.createElement('a');\\r\\n    a.download = name;\\r\\n    a.rel = 'noopener'; // tabnabbing\\r\\n    // TODO: detect chrome extensions & packaged apps\\r\\n    // a.target = '_blank'\\r\\n    if (typeof blob === 'string') {\\r\\n        // Support regular links\\r\\n        a.href = blob;\\r\\n        if (a.origin !== location.origin) {\\r\\n            if (corsEnabled(a.href)) {\\r\\n                download(blob, name, opts);\\r\\n            }\\r\\n            else {\\r\\n                a.target = '_blank';\\r\\n                click(a);\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            click(a);\\r\\n        }\\r\\n    }\\r\\n    else {\\r\\n        // Support blobs\\r\\n        a.href = URL.createObjectURL(blob);\\r\\n        setTimeout(function () {\\r\\n            URL.revokeObjectURL(a.href);\\r\\n        }, 4e4); // 40s\\r\\n        setTimeout(function () {\\r\\n            click(a);\\r\\n        }, 0);\\r\\n    }\\r\\n}\\r\\nfunction msSaveAs(blob, name = 'download', opts) {\\r\\n    if (typeof blob === 'string') {\\r\\n        if (corsEnabled(blob)) {\\r\\n            download(blob, name, opts);\\r\\n        }\\r\\n        else {\\r\\n            const a = document.createElement('a');\\r\\n            a.href = blob;\\r\\n            a.target = '_blank';\\r\\n            setTimeout(function () {\\r\\n                click(a);\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    else {\\r\\n        // @ts-ignore: works on windows\\r\\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\\r\\n    }\\r\\n}\\r\\nfunction fileSaverSaveAs(blob, name, opts, popup) {\\r\\n    // Open a popup immediately do go around popup blocker\\r\\n    // Mostly only available on user interaction and the fileReader is async so...\\r\\n    popup = popup || open('', '_blank');\\r\\n    if (popup) {\\r\\n        popup.document.title = popup.document.body.innerText = 'downloading...';\\r\\n    }\\r\\n    if (typeof blob === 'string')\\r\\n        return download(blob, name, opts);\\r\\n    const force = blob.type === 'application/octet-stream';\\r\\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\\r\\n    const isChromeIOS = /CriOS\\\\/[\\\\d]+/.test(navigator.userAgent);\\r\\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\\r\\n        typeof FileReader !== 'undefined') {\\r\\n        // Safari doesn't allow downloading of blob URLs\\r\\n        const reader = new FileReader();\\r\\n        reader.onloadend = function () {\\r\\n            let url = reader.result;\\r\\n            if (typeof url !== 'string') {\\r\\n                popup = null;\\r\\n                throw new Error('Wrong reader.result type');\\r\\n            }\\r\\n            url = isChromeIOS\\r\\n                ? url\\r\\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\\r\\n            if (popup) {\\r\\n                popup.location.href = url;\\r\\n            }\\r\\n            else {\\r\\n                location.assign(url);\\r\\n            }\\r\\n            popup = null; // reverse-tabnabbing #460\\r\\n        };\\r\\n        reader.readAsDataURL(blob);\\r\\n    }\\r\\n    else {\\r\\n        const url = URL.createObjectURL(blob);\\r\\n        if (popup)\\r\\n            popup.location.assign(url);\\r\\n        else\\r\\n            location.href = url;\\r\\n        popup = null; // reverse-tabnabbing #460\\r\\n        setTimeout(function () {\\r\\n            URL.revokeObjectURL(url);\\r\\n        }, 4e4); // 40s\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Shows a toast or console.log\\r\\n *\\r\\n * @param message - message to log\\r\\n * @param type - different color of the tooltip\\r\\n */\\r\\nfunction toastMessage(message, type) {\\r\\n    const piniaMessage = '🍍 ' + message;\\r\\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\\r\\n        // No longer available :(\\r\\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\\r\\n    }\\r\\n    else if (type === 'error') {\\r\\n        console.error(piniaMessage);\\r\\n    }\\r\\n    else if (type === 'warn') {\\r\\n        console.warn(piniaMessage);\\r\\n    }\\r\\n    else {\\r\\n        console.log(piniaMessage);\\r\\n    }\\r\\n}\\r\\nfunction isPinia(o) {\\r\\n    return '_a' in o && 'install' in o;\\r\\n}\\r\\n\\r\\n/**\\r\\n * This file contain devtools actions, they are not Pinia actions.\\r\\n */\\r\\n// ---\\r\\nfunction checkClipboardAccess() {\\r\\n    if (!('clipboard' in navigator)) {\\r\\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\nfunction checkNotFocusedError(error) {\\r\\n    if (error instanceof Error &&\\r\\n        error.message.toLowerCase().includes('document is not focused')) {\\r\\n        toastMessage('You need to activate the \\\"Emulate a focused page\\\" setting in the \\\"Rendering\\\" panel of devtools.', 'warn');\\r\\n        return true;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\nasync function actionGlobalCopyState(pinia) {\\r\\n    if (checkClipboardAccess())\\r\\n        return;\\r\\n    try {\\r\\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\\r\\n        toastMessage('Global state copied to clipboard.');\\r\\n    }\\r\\n    catch (error) {\\r\\n        if (checkNotFocusedError(error))\\r\\n            return;\\r\\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\\r\\n        console.error(error);\\r\\n    }\\r\\n}\\r\\nasync function actionGlobalPasteState(pinia) {\\r\\n    if (checkClipboardAccess())\\r\\n        return;\\r\\n    try {\\r\\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\\r\\n        toastMessage('Global state pasted from clipboard.');\\r\\n    }\\r\\n    catch (error) {\\r\\n        if (checkNotFocusedError(error))\\r\\n            return;\\r\\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\\r\\n        console.error(error);\\r\\n    }\\r\\n}\\r\\nasync function actionGlobalSaveState(pinia) {\\r\\n    try {\\r\\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\\r\\n            type: 'text/plain;charset=utf-8',\\r\\n        }), 'pinia-state.json');\\r\\n    }\\r\\n    catch (error) {\\r\\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\\r\\n        console.error(error);\\r\\n    }\\r\\n}\\r\\nlet fileInput;\\r\\nfunction getFileOpener() {\\r\\n    if (!fileInput) {\\r\\n        fileInput = document.createElement('input');\\r\\n        fileInput.type = 'file';\\r\\n        fileInput.accept = '.json';\\r\\n    }\\r\\n    function openFile() {\\r\\n        return new Promise((resolve, reject) => {\\r\\n            fileInput.onchange = async () => {\\r\\n                const files = fileInput.files;\\r\\n                if (!files)\\r\\n                    return resolve(null);\\r\\n                const file = files.item(0);\\r\\n                if (!file)\\r\\n                    return resolve(null);\\r\\n                return resolve({ text: await file.text(), file });\\r\\n            };\\r\\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\\r\\n            fileInput.oncancel = () => resolve(null);\\r\\n            fileInput.onerror = reject;\\r\\n            fileInput.click();\\r\\n        });\\r\\n    }\\r\\n    return openFile;\\r\\n}\\r\\nasync function actionGlobalOpenStateFile(pinia) {\\r\\n    try {\\r\\n        const open = getFileOpener();\\r\\n        const result = await open();\\r\\n        if (!result)\\r\\n            return;\\r\\n        const { text, file } = result;\\r\\n        loadStoresState(pinia, JSON.parse(text));\\r\\n        toastMessage(`Global state imported from \\\"${file.name}\\\".`);\\r\\n    }\\r\\n    catch (error) {\\r\\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\\r\\n        console.error(error);\\r\\n    }\\r\\n}\\r\\nfunction loadStoresState(pinia, state) {\\r\\n    for (const key in state) {\\r\\n        const storeState = pinia.state.value[key];\\r\\n        // store is already instantiated, patch it\\r\\n        if (storeState) {\\r\\n            Object.assign(storeState, state[key]);\\r\\n        }\\r\\n        else {\\r\\n            // store is not instantiated, set the initial state\\r\\n            pinia.state.value[key] = state[key];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction formatDisplay(display) {\\r\\n    return {\\r\\n        _custom: {\\r\\n            display,\\r\\n        },\\r\\n    };\\r\\n}\\r\\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\\r\\nconst PINIA_ROOT_ID = '_root';\\r\\nfunction formatStoreForInspectorTree(store) {\\r\\n    return isPinia(store)\\r\\n        ? {\\r\\n            id: PINIA_ROOT_ID,\\r\\n            label: PINIA_ROOT_LABEL,\\r\\n        }\\r\\n        : {\\r\\n            id: store.$id,\\r\\n            label: store.$id,\\r\\n        };\\r\\n}\\r\\nfunction formatStoreForInspectorState(store) {\\r\\n    if (isPinia(store)) {\\r\\n        const storeNames = Array.from(store._s.keys());\\r\\n        const storeMap = store._s;\\r\\n        const state = {\\r\\n            state: storeNames.map((storeId) => ({\\r\\n                editable: true,\\r\\n                key: storeId,\\r\\n                value: store.state.value[storeId],\\r\\n            })),\\r\\n            getters: storeNames\\r\\n                .filter((id) => storeMap.get(id)._getters)\\r\\n                .map((id) => {\\r\\n                const store = storeMap.get(id);\\r\\n                return {\\r\\n                    editable: false,\\r\\n                    key: id,\\r\\n                    value: store._getters.reduce((getters, key) => {\\r\\n                        getters[key] = store[key];\\r\\n                        return getters;\\r\\n                    }, {}),\\r\\n                };\\r\\n            }),\\r\\n        };\\r\\n        return state;\\r\\n    }\\r\\n    const state = {\\r\\n        state: Object.keys(store.$state).map((key) => ({\\r\\n            editable: true,\\r\\n            key,\\r\\n            value: store.$state[key],\\r\\n        })),\\r\\n    };\\r\\n    // avoid adding empty getters\\r\\n    if (store._getters && store._getters.length) {\\r\\n        state.getters = store._getters.map((getterName) => ({\\r\\n            editable: false,\\r\\n            key: getterName,\\r\\n            value: store[getterName],\\r\\n        }));\\r\\n    }\\r\\n    if (store._customProperties.size) {\\r\\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\\r\\n            editable: true,\\r\\n            key,\\r\\n            value: store[key],\\r\\n        }));\\r\\n    }\\r\\n    return state;\\r\\n}\\r\\nfunction formatEventData(events) {\\r\\n    if (!events)\\r\\n        return {};\\r\\n    if (Array.isArray(events)) {\\r\\n        // TODO: handle add and delete for arrays and objects\\r\\n        return events.reduce((data, event) => {\\r\\n            data.keys.push(event.key);\\r\\n            data.operations.push(event.type);\\r\\n            data.oldValue[event.key] = event.oldValue;\\r\\n            data.newValue[event.key] = event.newValue;\\r\\n            return data;\\r\\n        }, {\\r\\n            oldValue: {},\\r\\n            keys: [],\\r\\n            operations: [],\\r\\n            newValue: {},\\r\\n        });\\r\\n    }\\r\\n    else {\\r\\n        return {\\r\\n            operation: formatDisplay(events.type),\\r\\n            key: formatDisplay(events.key),\\r\\n            oldValue: events.oldValue,\\r\\n            newValue: events.newValue,\\r\\n        };\\r\\n    }\\r\\n}\\r\\nfunction formatMutationType(type) {\\r\\n    switch (type) {\\r\\n        case MutationType.direct:\\r\\n            return 'mutation';\\r\\n        case MutationType.patchFunction:\\r\\n            return '$patch';\\r\\n        case MutationType.patchObject:\\r\\n            return '$patch';\\r\\n        default:\\r\\n            return 'unknown';\\r\\n    }\\r\\n}\\r\\n\\r\\n// timeline can be paused when directly changing the state\\r\\nlet isTimelineActive = true;\\r\\nconst componentStateTypes = [];\\r\\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\\r\\nconst INSPECTOR_ID = 'pinia';\\r\\nconst { assign: assign$1 } = Object;\\r\\n/**\\r\\n * Gets the displayed name of a store in devtools\\r\\n *\\r\\n * @param id - id of the store\\r\\n * @returns a formatted string\\r\\n */\\r\\nconst getStoreType = (id) => '🍍 ' + id;\\r\\n/**\\r\\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\\r\\n * as soon as it is added to the application.\\r\\n *\\r\\n * @param app - Vue application\\r\\n * @param pinia - pinia instance\\r\\n */\\r\\nfunction registerPiniaDevtools(app, pinia) {\\r\\n    setupDevtoolsPlugin({\\r\\n        id: 'dev.esm.pinia',\\r\\n        label: 'Pinia 🍍',\\r\\n        logo: 'https://pinia.vuejs.org/logo.svg',\\r\\n        packageName: 'pinia',\\r\\n        homepage: 'https://pinia.vuejs.org',\\r\\n        componentStateTypes,\\r\\n        app,\\r\\n    }, (api) => {\\r\\n        if (typeof api.now !== 'function') {\\r\\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\\r\\n        }\\r\\n        api.addTimelineLayer({\\r\\n            id: MUTATIONS_LAYER_ID,\\r\\n            label: `Pinia 🍍`,\\r\\n            color: 0xe5df88,\\r\\n        });\\r\\n        api.addInspector({\\r\\n            id: INSPECTOR_ID,\\r\\n            label: 'Pinia 🍍',\\r\\n            icon: 'storage',\\r\\n            treeFilterPlaceholder: 'Search stores',\\r\\n            actions: [\\r\\n                {\\r\\n                    icon: 'content_copy',\\r\\n                    action: () => {\\r\\n                        actionGlobalCopyState(pinia);\\r\\n                    },\\r\\n                    tooltip: 'Serialize and copy the state',\\r\\n                },\\r\\n                {\\r\\n                    icon: 'content_paste',\\r\\n                    action: async () => {\\r\\n                        await actionGlobalPasteState(pinia);\\r\\n                        api.sendInspectorTree(INSPECTOR_ID);\\r\\n                        api.sendInspectorState(INSPECTOR_ID);\\r\\n                    },\\r\\n                    tooltip: 'Replace the state with the content of your clipboard',\\r\\n                },\\r\\n                {\\r\\n                    icon: 'save',\\r\\n                    action: () => {\\r\\n                        actionGlobalSaveState(pinia);\\r\\n                    },\\r\\n                    tooltip: 'Save the state as a JSON file',\\r\\n                },\\r\\n                {\\r\\n                    icon: 'folder_open',\\r\\n                    action: async () => {\\r\\n                        await actionGlobalOpenStateFile(pinia);\\r\\n                        api.sendInspectorTree(INSPECTOR_ID);\\r\\n                        api.sendInspectorState(INSPECTOR_ID);\\r\\n                    },\\r\\n                    tooltip: 'Import the state from a JSON file',\\r\\n                },\\r\\n            ],\\r\\n            nodeActions: [\\r\\n                {\\r\\n                    icon: 'restore',\\r\\n                    tooltip: 'Reset the state (with \\\"$reset\\\")',\\r\\n                    action: (nodeId) => {\\r\\n                        const store = pinia._s.get(nodeId);\\r\\n                        if (!store) {\\r\\n                            toastMessage(`Cannot reset \\\"${nodeId}\\\" store because it wasn't found.`, 'warn');\\r\\n                        }\\r\\n                        else if (typeof store.$reset !== 'function') {\\r\\n                            toastMessage(`Cannot reset \\\"${nodeId}\\\" store because it doesn't have a \\\"$reset\\\" method implemented.`, 'warn');\\r\\n                        }\\r\\n                        else {\\r\\n                            store.$reset();\\r\\n                            toastMessage(`Store \\\"${nodeId}\\\" reset.`);\\r\\n                        }\\r\\n                    },\\r\\n                },\\r\\n            ],\\r\\n        });\\r\\n        api.on.inspectComponent((payload, ctx) => {\\r\\n            const proxy = (payload.componentInstance &&\\r\\n                payload.componentInstance.proxy);\\r\\n            if (proxy && proxy._pStores) {\\r\\n                const piniaStores = payload.componentInstance.proxy._pStores;\\r\\n                Object.values(piniaStores).forEach((store) => {\\r\\n                    payload.instanceData.state.push({\\r\\n                        type: getStoreType(store.$id),\\r\\n                        key: 'state',\\r\\n                        editable: true,\\r\\n                        value: store._isOptionsAPI\\r\\n                            ? {\\r\\n                                _custom: {\\r\\n                                    value: toRaw(store.$state),\\r\\n                                    actions: [\\r\\n                                        {\\r\\n                                            icon: 'restore',\\r\\n                                            tooltip: 'Reset the state of this store',\\r\\n                                            action: () => store.$reset(),\\r\\n                                        },\\r\\n                                    ],\\r\\n                                },\\r\\n                            }\\r\\n                            : // NOTE: workaround to unwrap transferred refs\\r\\n                                Object.keys(store.$state).reduce((state, key) => {\\r\\n                                    state[key] = store.$state[key];\\r\\n                                    return state;\\r\\n                                }, {}),\\r\\n                    });\\r\\n                    if (store._getters && store._getters.length) {\\r\\n                        payload.instanceData.state.push({\\r\\n                            type: getStoreType(store.$id),\\r\\n                            key: 'getters',\\r\\n                            editable: false,\\r\\n                            value: store._getters.reduce((getters, key) => {\\r\\n                                try {\\r\\n                                    getters[key] = store[key];\\r\\n                                }\\r\\n                                catch (error) {\\r\\n                                    // @ts-expect-error: we just want to show it in devtools\\r\\n                                    getters[key] = error;\\r\\n                                }\\r\\n                                return getters;\\r\\n                            }, {}),\\r\\n                        });\\r\\n                    }\\r\\n                });\\r\\n            }\\r\\n        });\\r\\n        api.on.getInspectorTree((payload) => {\\r\\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\\r\\n                let stores = [pinia];\\r\\n                stores = stores.concat(Array.from(pinia._s.values()));\\r\\n                payload.rootNodes = (payload.filter\\r\\n                    ? stores.filter((store) => '$id' in store\\r\\n                        ? store.$id\\r\\n                            .toLowerCase()\\r\\n                            .includes(payload.filter.toLowerCase())\\r\\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\\r\\n                    : stores).map(formatStoreForInspectorTree);\\r\\n            }\\r\\n        });\\r\\n        api.on.getInspectorState((payload) => {\\r\\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\\r\\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\\r\\n                    ? pinia\\r\\n                    : pinia._s.get(payload.nodeId);\\r\\n                if (!inspectedStore) {\\r\\n                    // this could be the selected store restored for a different project\\r\\n                    // so it's better not to say anything here\\r\\n                    return;\\r\\n                }\\r\\n                if (inspectedStore) {\\r\\n                    payload.state = formatStoreForInspectorState(inspectedStore);\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n        api.on.editInspectorState((payload, ctx) => {\\r\\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\\r\\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\\r\\n                    ? pinia\\r\\n                    : pinia._s.get(payload.nodeId);\\r\\n                if (!inspectedStore) {\\r\\n                    return toastMessage(`store \\\"${payload.nodeId}\\\" not found`, 'error');\\r\\n                }\\r\\n                const { path } = payload;\\r\\n                if (!isPinia(inspectedStore)) {\\r\\n                    // access only the state\\r\\n                    if (path.length !== 1 ||\\r\\n                        !inspectedStore._customProperties.has(path[0]) ||\\r\\n                        path[0] in inspectedStore.$state) {\\r\\n                        path.unshift('$state');\\r\\n                    }\\r\\n                }\\r\\n                else {\\r\\n                    // Root access, we can omit the `.value` because the devtools API does it for us\\r\\n                    path.unshift('state');\\r\\n                }\\r\\n                isTimelineActive = false;\\r\\n                payload.set(inspectedStore, path, payload.state.value);\\r\\n                isTimelineActive = true;\\r\\n            }\\r\\n        });\\r\\n        api.on.editComponentState((payload) => {\\r\\n            if (payload.type.startsWith('🍍')) {\\r\\n                const storeId = payload.type.replace(/^🍍\\\\s*/, '');\\r\\n                const store = pinia._s.get(storeId);\\r\\n                if (!store) {\\r\\n                    return toastMessage(`store \\\"${storeId}\\\" not found`, 'error');\\r\\n                }\\r\\n                const { path } = payload;\\r\\n                if (path[0] !== 'state') {\\r\\n                    return toastMessage(`Invalid path for store \\\"${storeId}\\\":\\\\n${path}\\\\nOnly state can be modified.`);\\r\\n                }\\r\\n                // rewrite the first entry to be able to directly set the state as\\r\\n                // well as any other path\\r\\n                path[0] = '$state';\\r\\n                isTimelineActive = false;\\r\\n                payload.set(store, path, payload.state.value);\\r\\n                isTimelineActive = true;\\r\\n            }\\r\\n        });\\r\\n    });\\r\\n}\\r\\nfunction addStoreToDevtools(app, store) {\\r\\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\\r\\n        componentStateTypes.push(getStoreType(store.$id));\\r\\n    }\\r\\n    setupDevtoolsPlugin({\\r\\n        id: 'dev.esm.pinia',\\r\\n        label: 'Pinia 🍍',\\r\\n        logo: 'https://pinia.vuejs.org/logo.svg',\\r\\n        packageName: 'pinia',\\r\\n        homepage: 'https://pinia.vuejs.org',\\r\\n        componentStateTypes,\\r\\n        app,\\r\\n        settings: {\\r\\n            logStoreChanges: {\\r\\n                label: 'Notify about new/deleted stores',\\r\\n                type: 'boolean',\\r\\n                defaultValue: true,\\r\\n            },\\r\\n            // useEmojis: {\\r\\n            //   label: 'Use emojis in messages ⚡️',\\r\\n            //   type: 'boolean',\\r\\n            //   defaultValue: true,\\r\\n            // },\\r\\n        },\\r\\n    }, (api) => {\\r\\n        // gracefully handle errors\\r\\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\\r\\n        store.$onAction(({ after, onError, name, args }) => {\\r\\n            const groupId = runningActionId++;\\r\\n            api.addTimelineEvent({\\r\\n                layerId: MUTATIONS_LAYER_ID,\\r\\n                event: {\\r\\n                    time: now(),\\r\\n                    title: '🛫 ' + name,\\r\\n                    subtitle: 'start',\\r\\n                    data: {\\r\\n                        store: formatDisplay(store.$id),\\r\\n                        action: formatDisplay(name),\\r\\n                        args,\\r\\n                    },\\r\\n                    groupId,\\r\\n                },\\r\\n            });\\r\\n            after((result) => {\\r\\n                activeAction = undefined;\\r\\n                api.addTimelineEvent({\\r\\n                    layerId: MUTATIONS_LAYER_ID,\\r\\n                    event: {\\r\\n                        time: now(),\\r\\n                        title: '🛬 ' + name,\\r\\n                        subtitle: 'end',\\r\\n                        data: {\\r\\n                            store: formatDisplay(store.$id),\\r\\n                            action: formatDisplay(name),\\r\\n                            args,\\r\\n                            result,\\r\\n                        },\\r\\n                        groupId,\\r\\n                    },\\r\\n                });\\r\\n            });\\r\\n            onError((error) => {\\r\\n                activeAction = undefined;\\r\\n                api.addTimelineEvent({\\r\\n                    layerId: MUTATIONS_LAYER_ID,\\r\\n                    event: {\\r\\n                        time: now(),\\r\\n                        logType: 'error',\\r\\n                        title: '💥 ' + name,\\r\\n                        subtitle: 'end',\\r\\n                        data: {\\r\\n                            store: formatDisplay(store.$id),\\r\\n                            action: formatDisplay(name),\\r\\n                            args,\\r\\n                            error,\\r\\n                        },\\r\\n                        groupId,\\r\\n                    },\\r\\n                });\\r\\n            });\\r\\n        }, true);\\r\\n        store._customProperties.forEach((name) => {\\r\\n            watch(() => unref(store[name]), (newValue, oldValue) => {\\r\\n                api.notifyComponentUpdate();\\r\\n                api.sendInspectorState(INSPECTOR_ID);\\r\\n                if (isTimelineActive) {\\r\\n                    api.addTimelineEvent({\\r\\n                        layerId: MUTATIONS_LAYER_ID,\\r\\n                        event: {\\r\\n                            time: now(),\\r\\n                            title: 'Change',\\r\\n                            subtitle: name,\\r\\n                            data: {\\r\\n                                newValue,\\r\\n                                oldValue,\\r\\n                            },\\r\\n                            groupId: activeAction,\\r\\n                        },\\r\\n                    });\\r\\n                }\\r\\n            }, { deep: true });\\r\\n        });\\r\\n        store.$subscribe(({ events, type }, state) => {\\r\\n            api.notifyComponentUpdate();\\r\\n            api.sendInspectorState(INSPECTOR_ID);\\r\\n            if (!isTimelineActive)\\r\\n                return;\\r\\n            // rootStore.state[store.id] = state\\r\\n            const eventData = {\\r\\n                time: now(),\\r\\n                title: formatMutationType(type),\\r\\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\\r\\n                groupId: activeAction,\\r\\n            };\\r\\n            if (type === MutationType.patchFunction) {\\r\\n                eventData.subtitle = '⤵️';\\r\\n            }\\r\\n            else if (type === MutationType.patchObject) {\\r\\n                eventData.subtitle = '🧩';\\r\\n            }\\r\\n            else if (events && !Array.isArray(events)) {\\r\\n                eventData.subtitle = events.type;\\r\\n            }\\r\\n            if (events) {\\r\\n                eventData.data['rawEvent(s)'] = {\\r\\n                    _custom: {\\r\\n                        display: 'DebuggerEvent',\\r\\n                        type: 'object',\\r\\n                        tooltip: 'raw DebuggerEvent[]',\\r\\n                        value: events,\\r\\n                    },\\r\\n                };\\r\\n            }\\r\\n            api.addTimelineEvent({\\r\\n                layerId: MUTATIONS_LAYER_ID,\\r\\n                event: eventData,\\r\\n            });\\r\\n        }, { detached: true, flush: 'sync' });\\r\\n        const hotUpdate = store._hotUpdate;\\r\\n        store._hotUpdate = markRaw((newStore) => {\\r\\n            hotUpdate(newStore);\\r\\n            api.addTimelineEvent({\\r\\n                layerId: MUTATIONS_LAYER_ID,\\r\\n                event: {\\r\\n                    time: now(),\\r\\n                    title: '🔥 ' + store.$id,\\r\\n                    subtitle: 'HMR update',\\r\\n                    data: {\\r\\n                        store: formatDisplay(store.$id),\\r\\n                        info: formatDisplay(`HMR update`),\\r\\n                    },\\r\\n                },\\r\\n            });\\r\\n            // update the devtools too\\r\\n            api.notifyComponentUpdate();\\r\\n            api.sendInspectorTree(INSPECTOR_ID);\\r\\n            api.sendInspectorState(INSPECTOR_ID);\\r\\n        });\\r\\n        const { $dispose } = store;\\r\\n        store.$dispose = () => {\\r\\n            $dispose();\\r\\n            api.notifyComponentUpdate();\\r\\n            api.sendInspectorTree(INSPECTOR_ID);\\r\\n            api.sendInspectorState(INSPECTOR_ID);\\r\\n            api.getSettings().logStoreChanges &&\\r\\n                toastMessage(`Disposed \\\"${store.$id}\\\" store 🗑`);\\r\\n        };\\r\\n        // trigger an update so it can display new registered stores\\r\\n        api.notifyComponentUpdate();\\r\\n        api.sendInspectorTree(INSPECTOR_ID);\\r\\n        api.sendInspectorState(INSPECTOR_ID);\\r\\n        api.getSettings().logStoreChanges &&\\r\\n            toastMessage(`\\\"${store.$id}\\\" store installed 🆕`);\\r\\n    });\\r\\n}\\r\\nlet runningActionId = 0;\\r\\nlet activeAction;\\r\\n/**\\r\\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\\r\\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\\r\\n * mutation to the action.\\r\\n *\\r\\n * @param store - store to patch\\r\\n * @param actionNames - list of actionst to patch\\r\\n */\\r\\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\\r\\n    // original actions of the store as they are given by pinia. We are going to override them\\r\\n    const actions = actionNames.reduce((storeActions, actionName) => {\\r\\n        // use toRaw to avoid tracking #541\\r\\n        storeActions[actionName] = toRaw(store)[actionName];\\r\\n        return storeActions;\\r\\n    }, {});\\r\\n    for (const actionName in actions) {\\r\\n        store[actionName] = function () {\\r\\n            // the running action id is incremented in a before action hook\\r\\n            const _actionId = runningActionId;\\r\\n            const trackedStore = wrapWithProxy\\r\\n                ? new Proxy(store, {\\r\\n                    get(...args) {\\r\\n                        activeAction = _actionId;\\r\\n                        return Reflect.get(...args);\\r\\n                    },\\r\\n                    set(...args) {\\r\\n                        activeAction = _actionId;\\r\\n                        return Reflect.set(...args);\\r\\n                    },\\r\\n                })\\r\\n                : store;\\r\\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\\r\\n            activeAction = _actionId;\\r\\n            const retValue = actions[actionName].apply(trackedStore, arguments);\\r\\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\\r\\n            activeAction = undefined;\\r\\n            return retValue;\\r\\n        };\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * pinia.use(devtoolsPlugin)\\r\\n */\\r\\nfunction devtoolsPlugin({ app, store, options }) {\\r\\n    // HMR module\\r\\n    if (store.$id.startsWith('__hot:')) {\\r\\n        return;\\r\\n    }\\r\\n    // detect option api vs setup api\\r\\n    store._isOptionsAPI = !!options.state;\\r\\n    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\\r\\n    // Upgrade the HMR to also update the new actions\\r\\n    const originalHotUpdate = store._hotUpdate;\\r\\n    toRaw(store)._hotUpdate = function (newStore) {\\r\\n        originalHotUpdate.apply(this, arguments);\\r\\n        patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\\r\\n    };\\r\\n    addStoreToDevtools(app, \\r\\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\\r\\n    store);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates a Pinia instance to be used by the application\\r\\n */\\r\\nfunction createPinia() {\\r\\n    const scope = effectScope(true);\\r\\n    // NOTE: here we could check the window object for a state and directly set it\\r\\n    // if there is anything like it with Vue 3 SSR\\r\\n    const state = scope.run(() => ref({}));\\r\\n    let _p = [];\\r\\n    // plugins added before calling app.use(pinia)\\r\\n    let toBeInstalled = [];\\r\\n    const pinia = markRaw({\\r\\n        install(app) {\\r\\n            // this allows calling useStore() outside of a component setup after\\r\\n            // installing pinia's plugin\\r\\n            setActivePinia(pinia);\\r\\n            if (!isVue2) {\\r\\n                pinia._a = app;\\r\\n                app.provide(piniaSymbol, pinia);\\r\\n                app.config.globalProperties.$pinia = pinia;\\r\\n                /* istanbul ignore else */\\r\\n                if (USE_DEVTOOLS) {\\r\\n                    registerPiniaDevtools(app, pinia);\\r\\n                }\\r\\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\\r\\n                toBeInstalled = [];\\r\\n            }\\r\\n        },\\r\\n        use(plugin) {\\r\\n            if (!this._a && !isVue2) {\\r\\n                toBeInstalled.push(plugin);\\r\\n            }\\r\\n            else {\\r\\n                _p.push(plugin);\\r\\n            }\\r\\n            return this;\\r\\n        },\\r\\n        _p,\\r\\n        // it's actually undefined here\\r\\n        // @ts-expect-error\\r\\n        _a: null,\\r\\n        _e: scope,\\r\\n        _s: new Map(),\\r\\n        state,\\r\\n    });\\r\\n    // pinia devtools rely on dev only features so they cannot be forced unless\\r\\n    // the dev build of Vue is used. Avoid old browsers like IE11.\\r\\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\\r\\n        pinia.use(devtoolsPlugin);\\r\\n    }\\r\\n    return pinia;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Checks if a function is a `StoreDefinition`.\\r\\n *\\r\\n * @param fn - object to test\\r\\n * @returns true if `fn` is a StoreDefinition\\r\\n */\\r\\nconst isUseStore = (fn) => {\\r\\n    return typeof fn === 'function' && typeof fn.$id === 'string';\\r\\n};\\r\\n/**\\r\\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\\r\\n * remove any key not existing in `newState` and recursively merge plain\\r\\n * objects.\\r\\n *\\r\\n * @param newState - new state object to be patched\\r\\n * @param oldState - old state that should be used to patch newState\\r\\n * @returns - newState\\r\\n */\\r\\nfunction patchObject(newState, oldState) {\\r\\n    // no need to go through symbols because they cannot be serialized anyway\\r\\n    for (const key in oldState) {\\r\\n        const subPatch = oldState[key];\\r\\n        // skip the whole sub tree\\r\\n        if (!(key in newState)) {\\r\\n            continue;\\r\\n        }\\r\\n        const targetValue = newState[key];\\r\\n        if (isPlainObject(targetValue) &&\\r\\n            isPlainObject(subPatch) &&\\r\\n            !isRef(subPatch) &&\\r\\n            !isReactive(subPatch)) {\\r\\n            newState[key] = patchObject(targetValue, subPatch);\\r\\n        }\\r\\n        else {\\r\\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\\r\\n            // just set the whole thing\\r\\n            if (isVue2) {\\r\\n                set(newState, key, subPatch);\\r\\n            }\\r\\n            else {\\r\\n                newState[key] = subPatch;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return newState;\\r\\n}\\r\\n/**\\r\\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\\r\\n *\\r\\n * @example\\r\\n * ```js\\r\\n * const useUser = defineStore(...)\\r\\n * if (import.meta.hot) {\\r\\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * @param initialUseStore - return of the defineStore to hot update\\r\\n * @param hot - `import.meta.hot`\\r\\n */\\r\\nfunction acceptHMRUpdate(initialUseStore, hot) {\\r\\n    // strip as much as possible from iife.prod\\r\\n    if (!(process.env.NODE_ENV !== 'production')) {\\r\\n        return () => { };\\r\\n    }\\r\\n    return (newModule) => {\\r\\n        const pinia = hot.data.pinia || initialUseStore._pinia;\\r\\n        if (!pinia) {\\r\\n            // this store is still not used\\r\\n            return;\\r\\n        }\\r\\n        // preserve the pinia instance across loads\\r\\n        hot.data.pinia = pinia;\\r\\n        // console.log('got data', newStore)\\r\\n        for (const exportName in newModule) {\\r\\n            const useStore = newModule[exportName];\\r\\n            // console.log('checking for', exportName)\\r\\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\\r\\n                // console.log('Accepting update for', useStore.$id)\\r\\n                const id = useStore.$id;\\r\\n                if (id !== initialUseStore.$id) {\\r\\n                    console.warn(`The id of the store changed from \\\"${initialUseStore.$id}\\\" to \\\"${id}\\\". Reloading.`);\\r\\n                    // return import.meta.hot.invalidate()\\r\\n                    return hot.invalidate();\\r\\n                }\\r\\n                const existingStore = pinia._s.get(id);\\r\\n                if (!existingStore) {\\r\\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\\r\\n                    return;\\r\\n                }\\r\\n                useStore(pinia, existingStore);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n}\\r\\n\\r\\nconst noop = () => { };\\r\\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\\r\\n    subscriptions.push(callback);\\r\\n    const removeSubscription = () => {\\r\\n        const idx = subscriptions.indexOf(callback);\\r\\n        if (idx > -1) {\\r\\n            subscriptions.splice(idx, 1);\\r\\n            onCleanup();\\r\\n        }\\r\\n    };\\r\\n    if (!detached && getCurrentScope()) {\\r\\n        onScopeDispose(removeSubscription);\\r\\n    }\\r\\n    return removeSubscription;\\r\\n}\\r\\nfunction triggerSubscriptions(subscriptions, ...args) {\\r\\n    subscriptions.slice().forEach((callback) => {\\r\\n        callback(...args);\\r\\n    });\\r\\n}\\r\\n\\r\\nconst fallbackRunWithContext = (fn) => fn();\\r\\nfunction mergeReactiveObjects(target, patchToApply) {\\r\\n    // Handle Map instances\\r\\n    if (target instanceof Map && patchToApply instanceof Map) {\\r\\n        patchToApply.forEach((value, key) => target.set(key, value));\\r\\n    }\\r\\n    // Handle Set instances\\r\\n    if (target instanceof Set && patchToApply instanceof Set) {\\r\\n        patchToApply.forEach(target.add, target);\\r\\n    }\\r\\n    // no need to go through symbols because they cannot be serialized anyway\\r\\n    for (const key in patchToApply) {\\r\\n        if (!patchToApply.hasOwnProperty(key))\\r\\n            continue;\\r\\n        const subPatch = patchToApply[key];\\r\\n        const targetValue = target[key];\\r\\n        if (isPlainObject(targetValue) &&\\r\\n            isPlainObject(subPatch) &&\\r\\n            target.hasOwnProperty(key) &&\\r\\n            !isRef(subPatch) &&\\r\\n            !isReactive(subPatch)) {\\r\\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\\r\\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\\r\\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\\r\\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\\r\\n        }\\r\\n        else {\\r\\n            // @ts-expect-error: subPatch is a valid value\\r\\n            target[key] = subPatch;\\r\\n        }\\r\\n    }\\r\\n    return target;\\r\\n}\\r\\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\\r\\n    ? Symbol('pinia:skipHydration')\\r\\n    : /* istanbul ignore next */ Symbol();\\r\\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\\r\\n/**\\r\\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\\r\\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\\r\\n *\\r\\n * @param obj - target object\\r\\n * @returns obj\\r\\n */\\r\\nfunction skipHydrate(obj) {\\r\\n    return isVue2\\r\\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\\r\\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\\r\\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\\r\\n}\\r\\n/**\\r\\n * Returns whether a value should be hydrated\\r\\n *\\r\\n * @param obj - target variable\\r\\n * @returns true if `obj` should be hydrated\\r\\n */\\r\\nfunction shouldHydrate(obj) {\\r\\n    return isVue2\\r\\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\\r\\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\\r\\n}\\r\\nconst { assign } = Object;\\r\\nfunction isComputed(o) {\\r\\n    return !!(isRef(o) && o.effect);\\r\\n}\\r\\nfunction createOptionsStore(id, options, pinia, hot) {\\r\\n    const { state, actions, getters } = options;\\r\\n    const initialState = pinia.state.value[id];\\r\\n    let store;\\r\\n    function setup() {\\r\\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\\r\\n            /* istanbul ignore if */\\r\\n            if (isVue2) {\\r\\n                set(pinia.state.value, id, state ? state() : {});\\r\\n            }\\r\\n            else {\\r\\n                pinia.state.value[id] = state ? state() : {};\\r\\n            }\\r\\n        }\\r\\n        // avoid creating a state in pinia.state.value\\r\\n        const localState = (process.env.NODE_ENV !== 'production') && hot\\r\\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\\r\\n                toRefs(ref(state ? state() : {}).value)\\r\\n            : toRefs(pinia.state.value[id]);\\r\\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\\r\\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\\r\\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \\\"${name}\\\" in store \\\"${id}\\\".`);\\r\\n            }\\r\\n            computedGetters[name] = markRaw(computed(() => {\\r\\n                setActivePinia(pinia);\\r\\n                // it was created just before\\r\\n                const store = pinia._s.get(id);\\r\\n                // allow cross using stores\\r\\n                /* istanbul ignore next */\\r\\n                if (isVue2 && !store._r)\\r\\n                    return;\\r\\n                // @ts-expect-error\\r\\n                // return getters![name].call(context, context)\\r\\n                // TODO: avoid reading the getter while assigning with a global variable\\r\\n                return getters[name].call(store, store);\\r\\n            }));\\r\\n            return computedGetters;\\r\\n        }, {}));\\r\\n    }\\r\\n    store = createSetupStore(id, setup, options, pinia, hot, true);\\r\\n    return store;\\r\\n}\\r\\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\\r\\n    let scope;\\r\\n    const optionsForPlugin = assign({ actions: {} }, options);\\r\\n    /* istanbul ignore if */\\r\\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\\r\\n        throw new Error('Pinia destroyed');\\r\\n    }\\r\\n    // watcher options for $subscribe\\r\\n    const $subscribeOptions = {\\r\\n        deep: true,\\r\\n        // flush: 'post',\\r\\n    };\\r\\n    /* istanbul ignore else */\\r\\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\\r\\n        $subscribeOptions.onTrigger = (event) => {\\r\\n            /* istanbul ignore else */\\r\\n            if (isListening) {\\r\\n                debuggerEvents = event;\\r\\n                // avoid triggering this while the store is being built and the state is being set in pinia\\r\\n            }\\r\\n            else if (isListening == false && !store._hotUpdating) {\\r\\n                // let patch send all the events together later\\r\\n                /* istanbul ignore else */\\r\\n                if (Array.isArray(debuggerEvents)) {\\r\\n                    debuggerEvents.push(event);\\r\\n                }\\r\\n                else {\\r\\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\\r\\n                }\\r\\n            }\\r\\n        };\\r\\n    }\\r\\n    // internal state\\r\\n    let isListening; // set to true at the end\\r\\n    let isSyncListening; // set to true at the end\\r\\n    let subscriptions = [];\\r\\n    let actionSubscriptions = [];\\r\\n    let debuggerEvents;\\r\\n    const initialState = pinia.state.value[$id];\\r\\n    // avoid setting the state for option stores if it is set\\r\\n    // by the setup\\r\\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\\r\\n        /* istanbul ignore if */\\r\\n        if (isVue2) {\\r\\n            set(pinia.state.value, $id, {});\\r\\n        }\\r\\n        else {\\r\\n            pinia.state.value[$id] = {};\\r\\n        }\\r\\n    }\\r\\n    const hotState = ref({});\\r\\n    // avoid triggering too many listeners\\r\\n    // https://github.com/vuejs/pinia/issues/1129\\r\\n    let activeListener;\\r\\n    function $patch(partialStateOrMutator) {\\r\\n        let subscriptionMutation;\\r\\n        isListening = isSyncListening = false;\\r\\n        // reset the debugger events since patches are sync\\r\\n        /* istanbul ignore else */\\r\\n        if ((process.env.NODE_ENV !== 'production')) {\\r\\n            debuggerEvents = [];\\r\\n        }\\r\\n        if (typeof partialStateOrMutator === 'function') {\\r\\n            partialStateOrMutator(pinia.state.value[$id]);\\r\\n            subscriptionMutation = {\\r\\n                type: MutationType.patchFunction,\\r\\n                storeId: $id,\\r\\n                events: debuggerEvents,\\r\\n            };\\r\\n        }\\r\\n        else {\\r\\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\\r\\n            subscriptionMutation = {\\r\\n                type: MutationType.patchObject,\\r\\n                payload: partialStateOrMutator,\\r\\n                storeId: $id,\\r\\n                events: debuggerEvents,\\r\\n            };\\r\\n        }\\r\\n        const myListenerId = (activeListener = Symbol());\\r\\n        nextTick().then(() => {\\r\\n            if (activeListener === myListenerId) {\\r\\n                isListening = true;\\r\\n            }\\r\\n        });\\r\\n        isSyncListening = true;\\r\\n        // because we paused the watcher, we need to manually call the subscriptions\\r\\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\\r\\n    }\\r\\n    const $reset = isOptionsStore\\r\\n        ? function $reset() {\\r\\n            const { state } = options;\\r\\n            const newState = state ? state() : {};\\r\\n            // we use a patch to group all changes into one single subscription\\r\\n            this.$patch(($state) => {\\r\\n                assign($state, newState);\\r\\n            });\\r\\n        }\\r\\n        : /* istanbul ignore next */\\r\\n            (process.env.NODE_ENV !== 'production')\\r\\n                ? () => {\\r\\n                    throw new Error(`🍍: Store \\\"${$id}\\\" is built using the setup syntax and does not implement $reset().`);\\r\\n                }\\r\\n                : noop;\\r\\n    function $dispose() {\\r\\n        scope.stop();\\r\\n        subscriptions = [];\\r\\n        actionSubscriptions = [];\\r\\n        pinia._s.delete($id);\\r\\n    }\\r\\n    /**\\r\\n     * Wraps an action to handle subscriptions.\\r\\n     *\\r\\n     * @param name - name of the action\\r\\n     * @param action - action to wrap\\r\\n     * @returns a wrapped action to handle subscriptions\\r\\n     */\\r\\n    function wrapAction(name, action) {\\r\\n        return function () {\\r\\n            setActivePinia(pinia);\\r\\n            const args = Array.from(arguments);\\r\\n            const afterCallbackList = [];\\r\\n            const onErrorCallbackList = [];\\r\\n            function after(callback) {\\r\\n                afterCallbackList.push(callback);\\r\\n            }\\r\\n            function onError(callback) {\\r\\n                onErrorCallbackList.push(callback);\\r\\n            }\\r\\n            // @ts-expect-error\\r\\n            triggerSubscriptions(actionSubscriptions, {\\r\\n                args,\\r\\n                name,\\r\\n                store,\\r\\n                after,\\r\\n                onError,\\r\\n            });\\r\\n            let ret;\\r\\n            try {\\r\\n                ret = action.apply(this && this.$id === $id ? this : store, args);\\r\\n                // handle sync errors\\r\\n            }\\r\\n            catch (error) {\\r\\n                triggerSubscriptions(onErrorCallbackList, error);\\r\\n                throw error;\\r\\n            }\\r\\n            if (ret instanceof Promise) {\\r\\n                return ret\\r\\n                    .then((value) => {\\r\\n                    triggerSubscriptions(afterCallbackList, value);\\r\\n                    return value;\\r\\n                })\\r\\n                    .catch((error) => {\\r\\n                    triggerSubscriptions(onErrorCallbackList, error);\\r\\n                    return Promise.reject(error);\\r\\n                });\\r\\n            }\\r\\n            // trigger after callbacks\\r\\n            triggerSubscriptions(afterCallbackList, ret);\\r\\n            return ret;\\r\\n        };\\r\\n    }\\r\\n    const _hmrPayload = /*#__PURE__*/ markRaw({\\r\\n        actions: {},\\r\\n        getters: {},\\r\\n        state: [],\\r\\n        hotState,\\r\\n    });\\r\\n    const partialStore = {\\r\\n        _p: pinia,\\r\\n        // _s: scope,\\r\\n        $id,\\r\\n        $onAction: addSubscription.bind(null, actionSubscriptions),\\r\\n        $patch,\\r\\n        $reset,\\r\\n        $subscribe(callback, options = {}) {\\r\\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\\r\\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\\r\\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\\r\\n                    callback({\\r\\n                        storeId: $id,\\r\\n                        type: MutationType.direct,\\r\\n                        events: debuggerEvents,\\r\\n                    }, state);\\r\\n                }\\r\\n            }, assign({}, $subscribeOptions, options)));\\r\\n            return removeSubscription;\\r\\n        },\\r\\n        $dispose,\\r\\n    };\\r\\n    /* istanbul ignore if */\\r\\n    if (isVue2) {\\r\\n        // start as non ready\\r\\n        partialStore._r = false;\\r\\n    }\\r\\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\\r\\n        ? assign({\\r\\n            _hmrPayload,\\r\\n            _customProperties: markRaw(new Set()), // devtools custom properties\\r\\n        }, partialStore\\r\\n        // must be added later\\r\\n        // setupStore\\r\\n        )\\r\\n        : partialStore);\\r\\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\\r\\n    // creating infinite loops.\\r\\n    pinia._s.set($id, store);\\r\\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\\r\\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\\r\\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));\\r\\n    // overwrite existing actions to support $onAction\\r\\n    for (const key in setupStore) {\\r\\n        const prop = setupStore[key];\\r\\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\\r\\n            // mark it as a piece of state to be serialized\\r\\n            if ((process.env.NODE_ENV !== 'production') && hot) {\\r\\n                set(hotState.value, key, toRef(setupStore, key));\\r\\n                // createOptionStore directly sets the state in pinia.state.value so we\\r\\n                // can just skip that\\r\\n            }\\r\\n            else if (!isOptionsStore) {\\r\\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\\r\\n                if (initialState && shouldHydrate(prop)) {\\r\\n                    if (isRef(prop)) {\\r\\n                        prop.value = initialState[key];\\r\\n                    }\\r\\n                    else {\\r\\n                        // probably a reactive object, lets recursively assign\\r\\n                        // @ts-expect-error: prop is unknown\\r\\n                        mergeReactiveObjects(prop, initialState[key]);\\r\\n                    }\\r\\n                }\\r\\n                // transfer the ref to the pinia state to keep everything in sync\\r\\n                /* istanbul ignore if */\\r\\n                if (isVue2) {\\r\\n                    set(pinia.state.value[$id], key, prop);\\r\\n                }\\r\\n                else {\\r\\n                    pinia.state.value[$id][key] = prop;\\r\\n                }\\r\\n            }\\r\\n            /* istanbul ignore else */\\r\\n            if ((process.env.NODE_ENV !== 'production')) {\\r\\n                _hmrPayload.state.push(key);\\r\\n            }\\r\\n            // action\\r\\n        }\\r\\n        else if (typeof prop === 'function') {\\r\\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\\r\\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\\r\\n            // this a hot module replacement store because the hotUpdate method needs\\r\\n            // to do it with the right context\\r\\n            /* istanbul ignore if */\\r\\n            if (isVue2) {\\r\\n                set(setupStore, key, actionValue);\\r\\n            }\\r\\n            else {\\r\\n                // @ts-expect-error\\r\\n                setupStore[key] = actionValue;\\r\\n            }\\r\\n            /* istanbul ignore else */\\r\\n            if ((process.env.NODE_ENV !== 'production')) {\\r\\n                _hmrPayload.actions[key] = prop;\\r\\n            }\\r\\n            // list actions so they can be used in plugins\\r\\n            // @ts-expect-error\\r\\n            optionsForPlugin.actions[key] = prop;\\r\\n        }\\r\\n        else if ((process.env.NODE_ENV !== 'production')) {\\r\\n            // add getters for devtools\\r\\n            if (isComputed(prop)) {\\r\\n                _hmrPayload.getters[key] = isOptionsStore\\r\\n                    ? // @ts-expect-error\\r\\n                        options.getters[key]\\r\\n                    : prop;\\r\\n                if (IS_CLIENT) {\\r\\n                    const getters = setupStore._getters ||\\r\\n                        // @ts-expect-error: same\\r\\n                        (setupStore._getters = markRaw([]));\\r\\n                    getters.push(key);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    // add the state, getters, and action properties\\r\\n    /* istanbul ignore if */\\r\\n    if (isVue2) {\\r\\n        Object.keys(setupStore).forEach((key) => {\\r\\n            set(store, key, setupStore[key]);\\r\\n        });\\r\\n    }\\r\\n    else {\\r\\n        assign(store, setupStore);\\r\\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\\r\\n        // Make `storeToRefs()` work with `reactive()` #799\\r\\n        assign(toRaw(store), setupStore);\\r\\n    }\\r\\n    // use this instead of a computed with setter to be able to create it anywhere\\r\\n    // without linking the computed lifespan to wherever the store is first\\r\\n    // created.\\r\\n    Object.defineProperty(store, '$state', {\\r\\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\\r\\n        set: (state) => {\\r\\n            /* istanbul ignore if */\\r\\n            if ((process.env.NODE_ENV !== 'production') && hot) {\\r\\n                throw new Error('cannot set hotState');\\r\\n            }\\r\\n            $patch(($state) => {\\r\\n                assign($state, state);\\r\\n            });\\r\\n        },\\r\\n    });\\r\\n    // add the hotUpdate before plugins to allow them to override it\\r\\n    /* istanbul ignore else */\\r\\n    if ((process.env.NODE_ENV !== 'production')) {\\r\\n        store._hotUpdate = markRaw((newStore) => {\\r\\n            store._hotUpdating = true;\\r\\n            newStore._hmrPayload.state.forEach((stateKey) => {\\r\\n                if (stateKey in store.$state) {\\r\\n                    const newStateTarget = newStore.$state[stateKey];\\r\\n                    const oldStateSource = store.$state[stateKey];\\r\\n                    if (typeof newStateTarget === 'object' &&\\r\\n                        isPlainObject(newStateTarget) &&\\r\\n                        isPlainObject(oldStateSource)) {\\r\\n                        patchObject(newStateTarget, oldStateSource);\\r\\n                    }\\r\\n                    else {\\r\\n                        // transfer the ref\\r\\n                        newStore.$state[stateKey] = oldStateSource;\\r\\n                    }\\r\\n                }\\r\\n                // patch direct access properties to allow store.stateProperty to work as\\r\\n                // store.$state.stateProperty\\r\\n                set(store, stateKey, toRef(newStore.$state, stateKey));\\r\\n            });\\r\\n            // remove deleted state properties\\r\\n            Object.keys(store.$state).forEach((stateKey) => {\\r\\n                if (!(stateKey in newStore.$state)) {\\r\\n                    del(store, stateKey);\\r\\n                }\\r\\n            });\\r\\n            // avoid devtools logging this as a mutation\\r\\n            isListening = false;\\r\\n            isSyncListening = false;\\r\\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\\r\\n            isSyncListening = true;\\r\\n            nextTick().then(() => {\\r\\n                isListening = true;\\r\\n            });\\r\\n            for (const actionName in newStore._hmrPayload.actions) {\\r\\n                const action = newStore[actionName];\\r\\n                set(store, actionName, wrapAction(actionName, action));\\r\\n            }\\r\\n            // TODO: does this work in both setup and option store?\\r\\n            for (const getterName in newStore._hmrPayload.getters) {\\r\\n                const getter = newStore._hmrPayload.getters[getterName];\\r\\n                const getterValue = isOptionsStore\\r\\n                    ? // special handling of options api\\r\\n                        computed(() => {\\r\\n                            setActivePinia(pinia);\\r\\n                            return getter.call(store, store);\\r\\n                        })\\r\\n                    : getter;\\r\\n                set(store, getterName, getterValue);\\r\\n            }\\r\\n            // remove deleted getters\\r\\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\\r\\n                if (!(key in newStore._hmrPayload.getters)) {\\r\\n                    del(store, key);\\r\\n                }\\r\\n            });\\r\\n            // remove old actions\\r\\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\\r\\n                if (!(key in newStore._hmrPayload.actions)) {\\r\\n                    del(store, key);\\r\\n                }\\r\\n            });\\r\\n            // update the values used in devtools and to allow deleting new properties later on\\r\\n            store._hmrPayload = newStore._hmrPayload;\\r\\n            store._getters = newStore._getters;\\r\\n            store._hotUpdating = false;\\r\\n        });\\r\\n    }\\r\\n    if (USE_DEVTOOLS) {\\r\\n        const nonEnumerable = {\\r\\n            writable: true,\\r\\n            configurable: true,\\r\\n            // avoid warning on devtools trying to display this property\\r\\n            enumerable: false,\\r\\n        };\\r\\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\\r\\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\\r\\n        });\\r\\n    }\\r\\n    /* istanbul ignore if */\\r\\n    if (isVue2) {\\r\\n        // mark the store as ready before plugins\\r\\n        store._r = true;\\r\\n    }\\r\\n    // apply all plugins\\r\\n    pinia._p.forEach((extender) => {\\r\\n        /* istanbul ignore else */\\r\\n        if (USE_DEVTOOLS) {\\r\\n            const extensions = scope.run(() => extender({\\r\\n                store,\\r\\n                app: pinia._a,\\r\\n                pinia,\\r\\n                options: optionsForPlugin,\\r\\n            }));\\r\\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\\r\\n            assign(store, extensions);\\r\\n        }\\r\\n        else {\\r\\n            assign(store, scope.run(() => extender({\\r\\n                store,\\r\\n                app: pinia._a,\\r\\n                pinia,\\r\\n                options: optionsForPlugin,\\r\\n            })));\\r\\n        }\\r\\n    });\\r\\n    if ((process.env.NODE_ENV !== 'production') &&\\r\\n        store.$state &&\\r\\n        typeof store.$state === 'object' &&\\r\\n        typeof store.$state.constructor === 'function' &&\\r\\n        !store.$state.constructor.toString().includes('[native code]')) {\\r\\n        console.warn(`[🍍]: The \\\"state\\\" must be a plain object. It cannot be\\\\n` +\\r\\n            `\\\\tstate: () => new MyClass()\\\\n` +\\r\\n            `Found in store \\\"${store.$id}\\\".`);\\r\\n    }\\r\\n    // only apply hydrate to option stores with an initial state in pinia\\r\\n    if (initialState &&\\r\\n        isOptionsStore &&\\r\\n        options.hydrate) {\\r\\n        options.hydrate(store.$state, initialState);\\r\\n    }\\r\\n    isListening = true;\\r\\n    isSyncListening = true;\\r\\n    return store;\\r\\n}\\r\\nfunction defineStore(\\r\\n// TODO: add proper types from above\\r\\nidOrOptions, setup, setupOptions) {\\r\\n    let id;\\r\\n    let options;\\r\\n    const isSetupStore = typeof setup === 'function';\\r\\n    if (typeof idOrOptions === 'string') {\\r\\n        id = idOrOptions;\\r\\n        // the option store setup will contain the actual options in this case\\r\\n        options = isSetupStore ? setupOptions : setup;\\r\\n    }\\r\\n    else {\\r\\n        options = idOrOptions;\\r\\n        id = idOrOptions.id;\\r\\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\\r\\n            throw new Error(`[🍍]: \\\"defineStore()\\\" must be passed a store id as its first argument.`);\\r\\n        }\\r\\n    }\\r\\n    function useStore(pinia, hot) {\\r\\n        const hasContext = hasInjectionContext();\\r\\n        pinia =\\r\\n            // in test mode, ignore the argument provided as we can always retrieve a\\r\\n            // pinia instance with getActivePinia()\\r\\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\\r\\n                (hasContext ? inject(piniaSymbol, null) : null);\\r\\n        if (pinia)\\r\\n            setActivePinia(pinia);\\r\\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\\r\\n            throw new Error(`[🍍]: \\\"getActivePinia()\\\" was called but there was no active Pinia. Are you trying to use a store before calling \\\"app.use(pinia)\\\"?\\\\n` +\\r\\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\\\n` +\\r\\n                `This will fail in production.`);\\r\\n        }\\r\\n        pinia = activePinia;\\r\\n        if (!pinia._s.has(id)) {\\r\\n            // creating the store registers it in `pinia._s`\\r\\n            if (isSetupStore) {\\r\\n                createSetupStore(id, setup, options, pinia);\\r\\n            }\\r\\n            else {\\r\\n                createOptionsStore(id, options, pinia);\\r\\n            }\\r\\n            /* istanbul ignore else */\\r\\n            if ((process.env.NODE_ENV !== 'production')) {\\r\\n                // @ts-expect-error: not the right inferred type\\r\\n                useStore._pinia = pinia;\\r\\n            }\\r\\n        }\\r\\n        const store = pinia._s.get(id);\\r\\n        if ((process.env.NODE_ENV !== 'production') && hot) {\\r\\n            const hotId = '__hot:' + id;\\r\\n            const newStore = isSetupStore\\r\\n                ? createSetupStore(hotId, setup, options, pinia, true)\\r\\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\\r\\n            hot._hotUpdate(newStore);\\r\\n            // cleanup the state properties and the store from the cache\\r\\n            delete pinia.state.value[hotId];\\r\\n            pinia._s.delete(hotId);\\r\\n        }\\r\\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\\r\\n            const currentInstance = getCurrentInstance();\\r\\n            // save stores in instances to access them devtools\\r\\n            if (currentInstance &&\\r\\n                currentInstance.proxy &&\\r\\n                // avoid adding stores that are just built for hot module replacement\\r\\n                !hot) {\\r\\n                const vm = currentInstance.proxy;\\r\\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\\r\\n                cache[id] = store;\\r\\n            }\\r\\n        }\\r\\n        // StoreGeneric cannot be casted towards Store\\r\\n        return store;\\r\\n    }\\r\\n    useStore.$id = id;\\r\\n    return useStore;\\r\\n}\\r\\n\\r\\nlet mapStoreSuffix = 'Store';\\r\\n/**\\r\\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\\r\\n * Defaults to `\\\"Store\\\"`. Make sure to extend the MapStoresCustomization\\r\\n * interface if you are using TypeScript.\\r\\n *\\r\\n * @param suffix - new suffix\\r\\n */\\r\\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\\r\\n) {\\r\\n    mapStoreSuffix = suffix;\\r\\n}\\r\\n/**\\r\\n * Allows using stores without the composition API (`setup()`) by generating an\\r\\n * object to be spread in the `computed` field of a component. It accepts a list\\r\\n * of store definitions.\\r\\n *\\r\\n * @example\\r\\n * ```js\\r\\n * export default {\\r\\n *   computed: {\\r\\n *     // other computed properties\\r\\n *     ...mapStores(useUserStore, useCartStore)\\r\\n *   },\\r\\n *\\r\\n *   created() {\\r\\n *     this.userStore // store with id \\\"user\\\"\\r\\n *     this.cartStore // store with id \\\"cart\\\"\\r\\n *   }\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * @param stores - list of stores to map to an object\\r\\n */\\r\\nfunction mapStores(...stores) {\\r\\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\\r\\n        console.warn(`[🍍]: Directly pass all stores to \\\"mapStores()\\\" without putting them in an array:\\\\n` +\\r\\n            `Replace\\\\n` +\\r\\n            `\\\\tmapStores([useAuthStore, useCartStore])\\\\n` +\\r\\n            `with\\\\n` +\\r\\n            `\\\\tmapStores(useAuthStore, useCartStore)\\\\n` +\\r\\n            `This will fail in production if not fixed.`);\\r\\n        stores = stores[0];\\r\\n    }\\r\\n    return stores.reduce((reduced, useStore) => {\\r\\n        // @ts-expect-error: $id is added by defineStore\\r\\n        reduced[useStore.$id + mapStoreSuffix] = function () {\\r\\n            return useStore(this.$pinia);\\r\\n        };\\r\\n        return reduced;\\r\\n    }, {});\\r\\n}\\r\\n/**\\r\\n * Allows using state and getters from one store without using the composition\\r\\n * API (`setup()`) by generating an object to be spread in the `computed` field\\r\\n * of a component.\\r\\n *\\r\\n * @param useStore - store to map from\\r\\n * @param keysOrMapper - array or object\\r\\n */\\r\\nfunction mapState(useStore, keysOrMapper) {\\r\\n    return Array.isArray(keysOrMapper)\\r\\n        ? keysOrMapper.reduce((reduced, key) => {\\r\\n            reduced[key] = function () {\\r\\n                return useStore(this.$pinia)[key];\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {})\\r\\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\\r\\n            // @ts-expect-error\\r\\n            reduced[key] = function () {\\r\\n                const store = useStore(this.$pinia);\\r\\n                const storeKey = keysOrMapper[key];\\r\\n                // for some reason TS is unable to infer the type of storeKey to be a\\r\\n                // function\\r\\n                return typeof storeKey === 'function'\\r\\n                    ? storeKey.call(this, store)\\r\\n                    : store[storeKey];\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {});\\r\\n}\\r\\n/**\\r\\n * Alias for `mapState()`. You should use `mapState()` instead.\\r\\n * @deprecated use `mapState()` instead.\\r\\n */\\r\\nconst mapGetters = mapState;\\r\\n/**\\r\\n * Allows directly using actions from your store without using the composition\\r\\n * API (`setup()`) by generating an object to be spread in the `methods` field\\r\\n * of a component.\\r\\n *\\r\\n * @param useStore - store to map from\\r\\n * @param keysOrMapper - array or object\\r\\n */\\r\\nfunction mapActions(useStore, keysOrMapper) {\\r\\n    return Array.isArray(keysOrMapper)\\r\\n        ? keysOrMapper.reduce((reduced, key) => {\\r\\n            // @ts-expect-error\\r\\n            reduced[key] = function (...args) {\\r\\n                return useStore(this.$pinia)[key](...args);\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {})\\r\\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\\r\\n            // @ts-expect-error\\r\\n            reduced[key] = function (...args) {\\r\\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {});\\r\\n}\\r\\n/**\\r\\n * Allows using state and getters from one store without using the composition\\r\\n * API (`setup()`) by generating an object to be spread in the `computed` field\\r\\n * of a component.\\r\\n *\\r\\n * @param useStore - store to map from\\r\\n * @param keysOrMapper - array or object\\r\\n */\\r\\nfunction mapWritableState(useStore, keysOrMapper) {\\r\\n    return Array.isArray(keysOrMapper)\\r\\n        ? keysOrMapper.reduce((reduced, key) => {\\r\\n            // @ts-ignore\\r\\n            reduced[key] = {\\r\\n                get() {\\r\\n                    return useStore(this.$pinia)[key];\\r\\n                },\\r\\n                set(value) {\\r\\n                    // it's easier to type it here as any\\r\\n                    return (useStore(this.$pinia)[key] = value);\\r\\n                },\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {})\\r\\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\\r\\n            // @ts-ignore\\r\\n            reduced[key] = {\\r\\n                get() {\\r\\n                    return useStore(this.$pinia)[keysOrMapper[key]];\\r\\n                },\\r\\n                set(value) {\\r\\n                    // it's easier to type it here as any\\r\\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\\r\\n                },\\r\\n            };\\r\\n            return reduced;\\r\\n        }, {});\\r\\n}\\r\\n\\r\\n/**\\r\\n * Creates an object of references with all the state, getters, and plugin-added\\r\\n * state properties of the store. Similar to `toRefs()` but specifically\\r\\n * designed for Pinia stores so methods and non reactive properties are\\r\\n * completely ignored.\\r\\n *\\r\\n * @param store - store to extract the refs from\\r\\n */\\r\\nfunction storeToRefs(store) {\\r\\n    // See https://github.com/vuejs/pinia/issues/852\\r\\n    // It's easier to just use toRefs() even if it includes more stuff\\r\\n    if (isVue2) {\\r\\n        // @ts-expect-error: toRefs include methods and others\\r\\n        return toRefs(store);\\r\\n    }\\r\\n    else {\\r\\n        store = toRaw(store);\\r\\n        const refs = {};\\r\\n        for (const key in store) {\\r\\n            const value = store[key];\\r\\n            if (isRef(value) || isReactive(value)) {\\r\\n                // @ts-expect-error: the key is state or getter\\r\\n                refs[key] =\\r\\n                    // ---\\r\\n                    toRef(store, key);\\r\\n            }\\r\\n        }\\r\\n        return refs;\\r\\n    }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\\r\\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\\r\\n * https://pinia.vuejs.org/ssr/nuxt.html.\\r\\n *\\r\\n * @example\\r\\n * ```js\\r\\n * import Vue from 'vue'\\r\\n * import { PiniaVuePlugin, createPinia } from 'pinia'\\r\\n *\\r\\n * Vue.use(PiniaVuePlugin)\\r\\n * const pinia = createPinia()\\r\\n *\\r\\n * new Vue({\\r\\n *   el: '#app',\\r\\n *   // ...\\r\\n *   pinia,\\r\\n * })\\r\\n * ```\\r\\n *\\r\\n * @param _Vue - `Vue` imported from 'vue'.\\r\\n */\\r\\nconst PiniaVuePlugin = function (_Vue) {\\r\\n    // Equivalent of\\r\\n    // app.config.globalProperties.$pinia = pinia\\r\\n    _Vue.mixin({\\r\\n        beforeCreate() {\\r\\n            const options = this.$options;\\r\\n            if (options.pinia) {\\r\\n                const pinia = options.pinia;\\r\\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\\r\\n                /* istanbul ignore else */\\r\\n                if (!this._provided) {\\r\\n                    const provideCache = {};\\r\\n                    Object.defineProperty(this, '_provided', {\\r\\n                        get: () => provideCache,\\r\\n                        set: (v) => Object.assign(provideCache, v),\\r\\n                    });\\r\\n                }\\r\\n                this._provided[piniaSymbol] = pinia;\\r\\n                // propagate the pinia instance in an SSR friendly way\\r\\n                // avoid adding it to nuxt twice\\r\\n                /* istanbul ignore else */\\r\\n                if (!this.$pinia) {\\r\\n                    this.$pinia = pinia;\\r\\n                }\\r\\n                pinia._a = this;\\r\\n                if (IS_CLIENT) {\\r\\n                    // this allows calling useStore() outside of a component setup after\\r\\n                    // installing pinia's plugin\\r\\n                    setActivePinia(pinia);\\r\\n                }\\r\\n                if (USE_DEVTOOLS) {\\r\\n                    registerPiniaDevtools(pinia._a, pinia);\\r\\n                }\\r\\n            }\\r\\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\\r\\n                this.$pinia = options.parent.$pinia;\\r\\n            }\\r\\n        },\\r\\n        destroyed() {\\r\\n            delete this._pStores;\\r\\n        },\\r\\n    });\\r\\n};\\r\\n\\r\\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\\r\\n\"],\n  \"mappings\": \"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\",\n  \"names\": [\"MutationType\", \"open\", \"state\", \"store\", \"$reset\", \"options\"]\n}\n"
    },
    {
      "name": "vite:css-post",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "post"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1714315495422,
      "end": 1714315495422,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-template",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1714315495423,
      "end": 1714315495423,
      "order": "normal"
    }
  ]
}
